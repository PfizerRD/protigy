################################################################################################################
## Filename: server.r
## Created: October 09, 2015
## Author(s): Karsten Krug
##
## Purpose: Shiny-app to perform differential expression analysis, primarily on proteomics data, to perform
##          simple data QC, to interactively browse through the results and to download high-quality result
##          figures.
##
## This file defines the server logical of the app. It also takes care of most of the user interface.
##
################################################################################################################
library(shiny)

############################################
## set maximum file size for upload
############################################
options(shiny.maxRequestSize = MAXSIZEMB*1024^2)


###########################################################################################################
##                         Define server logic
###########################################################################################################
shinyServer(

    function(input, output, session) {

        #####################################
        ## reactive variables to store
        ## data accross a session
        #####################################

        ## error messages
        error <- reactiveValues()

        ## test results
        global.results <-  reactiveValues(
            data=NULL,
            table.norm=NULL,
            export.results=F,
            table.repro.filt=NULL,
            pca=NULL,
            table.log=NULL,
            repro.filt=NULL
        )
        ## input data
        global.input <- reactiveValues()
        ## parameters
        global.param <-  reactiveValues(
            session=NULL,                ## session id
            grp=NULL,                    ## the actual group assignment
            N.grp=NULL,                  ## number of defined groups
            grp.colors=NULL,             ## group color assignment
            grp.colors.legend=NULL,      ## group colors, names are group names
            grp.done=F,                  ## group assignment finished?
            which.test='One-sample mod T', ## specify test
            log.transform='none',        ## log transformation
            norm.data='none',            ## data normalization
            repro.filt='no',              ## reproducibility filter
            session.imported=F,          ## flag whether this is an imported session
            analysis.run=F,              ## flag whether the analysis has been run
            filter.type='adj.p',
            filter.value=0.05
        )
        ## plotting params
        plotparams <- reactiveValues(
            ## multiscatter
            ms.max=FALSE,
            ms.min.val=-4,
            ms.max.val=4
        )

        ## coordinates in volcano plot
        volc <- reactiveValues()

        ################################################################################
        ##
        ##                                instructions / help pages
        ##
        ################################################################################

        #############################
        ## getting started
        output$help.start <- renderText({

            if( !is.null(error$msg) ) return()

            if(!is.null(input$file)) return()
            if(!is.null(global.input$file)) return()

            HTML( paste('<p><h3>Hello Proteomics Broadies!</h3><br><font size=\"4\">Welcome to <b>modT</b>, the Shiny-app that allows you to perform moderated versions of the <b>one-sample</b> and <b>two-sample T-tests</b> as well as <b>F-test</b> and to interactively explore the results. You can upload ratio reports generated by <b>Spectrum Mill</b> or any other kind of text file containing expression data and optional annotation columns.</font></p><br><br><br>',

'<hr><p><font size=\"5\" color=\"red\">What\'s new:</font></p>',
'<font size=\"4\">
<b>v0.4.4</b>
<ul>
<li>New \'Export\'-tab to download a zip-file containing:
 <ul>
   <li>all figures (pdf).</li>
   <li>result table (xlsx).</li>
   <li>session file (Rdata) which can be imported back into the app.</li>
   <li>parameter file (txt)</li>
 </ul>
<li>Directionality of two-sample test is now indicated in the volcano plots.</li>
<li>Error handling for two-component normalization.</li>
<li>Profile plots under \'QC\'-tab</li>
</ul>
<b>v0.4.3</b>
<ul>
<li>Session export/import.</li>
<li>"#VALUE!"-entries from Excel can be handeled now.</li>
<li>Fixed bug causing PDF export of heatmap with user defined max. values to crash.</li>
</ul>
<b>v0.4.2</b>
<ul>
<li>Fixed a bug in 2-sample test that occured whenever the names of different groups defined the experimental design file started with the same series of characters, e.g. \'ABC\' and \'ABCD\'.</li>
</ul>
<b>v0.4.1</b>
<ul>
<li>Novel tab summarizing the analysis.</i>
<li>Data can now be log-transformed, e.g. for MaxQuant results.</li>
<li>Added option to skip testing, e.g. for PCA analysis.</li>
<li>User can specify principle components in the PCA scatterplot.</li>
</ul>
<b>v0.4</b>
<ul>
<li>Integration of moderated F statistics</li>
<li>Disabled column-based clustering one-sample and two-sample tests if multiple groups are being compared.</li>
</ul>
<b>v0.3</b>
<ul>
<li>Data normalization.</li>
<li>Reproducibility filter.</li>
<li>Upload/download of experimental design files.</li>
<li>Download of native Excel files.</li>
<li>Integration of the D3-based plotly library.</li>
</ul>
<b>v0.1</b>
<ul>
<li>First prototype.</li>
</ul>
</font>'
,sep='') )

        })

        ##############################
        ## help upload
        output$help.id.column <- renderText({

            if(global.param$analysis.run) return()
            if( !is.null(error$msg) ) return()

            if(is.null(input$id.col)) return()
            if(input$id.col > 0 && !is.null(input$id.col.value)) return()

            HTML( paste('<br><br><p><font size=\"4\">Here you can download a template of an experimental design file. You can open this file in Excel and define the groups you want to compare. Replicate measurements have to be grouped under a single name in the \'Experiment\'-column. Please avoid any special character when defining these names!</font></p>') )
        })

        ##############################
        ## help experimental design
        output$help.exp.design <- renderText({

            if(global.param$analysis.run) return()
            if( !is.null(error$msg) ) return()

            if(is.null(input$id.col)) return()
            if(input$id.col ==0) return()
            if(global.param$grp.done == T) return()

            HTML( paste('<br><br><p><font size=\"4\">Please upload the experimental design file that you have created using the upload button on the left.</p>') )

        })

        ################################
        ## help test
        output$help.test <- renderText({

            if(global.param$analysis.run) return()
            if( !is.null(error$msg) ) return()

            if(global.param$grp.done == F) return()
            if(!is.null(input$run.test))
                if(input$run.test > 0) return()

            HTML( paste('<font size=\"4\">
<p><h3>Log-transformation</h3>Apply log transformation to the data.</p>
<p><h3>Data normalization</h3>You can apply different normalization methods to the data prior to testing. The methods are applied for each column separately, except for \'Quantile\'-normalization which takes the entire matrix into account.</p>
<p>
<ul>
<li><b>Median</b>: Substract the sample median from each value.</li>
<li><b>Median-MAD</b>: Substract the sample median and divide by sample MAD.</li>
<li><b>2-component</b>: Use a mixture-model approach to separate non-changing from changing features and divide both populations by the median of the non-changing features.</li>
<li><b>Quantile</b>: Transform the data such that the quantiles of all sample distributions are the equal.</li>
<li><b>none</b>: The data will be taken as is. Should be used if the data has been already normalized.</li>
</ul>
<br><p><h3>Reproducibility filter</h3>This option is only considered in a <b>one-sample test</b> and will be ignored otherwise. For duplicate measurements a Bland-Altman Filter of 99.9% (+/-3.29 sigma) will be applied. For more than two replicate measurements per group a generalized reproducibility filter is applied which is based on a linear mixed effects model to model the within-group variance and between-group variance (See \'MethComp book (pp 58-61). <i>Comparing Clinical Measurement Methods</i> by Bendix Carstensen\' for more details). You can inspect the results of the filtering step in the multiscatter plot under the \'QC\'-tab. Data points removed prior to testing will be depicted in red.</p>

<br><h3>Select test</h3>You can choose between a one-sample, two-sample moderate T-tests, moderated F-test or no testing.
<ul>
<li><b>One-sample mod T</b>: For each test whether the group mean is significantly different from zero. Only meaningful to <b>ratio data</b>!</li>
<li><b>Two-sample mod T</b>: For each possible pairwise comparison of groups test whether the group means are significantly different from each other.</li>
<li><b>mod F</b>: Test whether there is a significant difference between any of the difined groups. Should be used if more than 2 groups are being compared. Only meaningful to <b>ratio data</b>!</li>
<li><b>none</b>: Don\'t do any test. Useful for data exploration such as PCA.</li>
</ul>
<br></font></p>' ) )
        })

        ################################
        ## help results
        output$help.results <- renderText({

            if( !is.null(error$msg) ) return()

            if(global.param$grp.done == F) return()
            if(!is.null(input$run.test))
                if(input$run.test == 0) return()

            HTML( paste('<p><font size=\"4\">This page allows you to interactively explore the results of you analyis. On the left you can choose between different filters, the results will be updated immediately. The filter that you specify applies to all tabs (\'Heatmap\', \'Volcanos\', ...), except the \'QC\' which shows the entire dataset. You can change the appearance of the heatmap by modifying the parameters below, you can select points shown in the Volcano plots and browse through the result table.</font></p><br>') )
        })

        #################################
        ## F5 hint
        output$F5hint <- renderText({

            HTML('<p align=\"center\"><font size=\"5\"><mark>To analyze another data set or to start over hit the F5 button.</mark></font></p>' )

        })

        #####################################
        ## Error messages
        output$error <- renderText({
            if( is.null(error$msg) ) return()
            HTML(paste('<p align=\"center\"><font size=\"5\" color=\"red\">', error$msg,'</font></p>'))
        })

        ################################################################################
        ##
        ##                                navigation bar
        ##
        ################################################################################
        output$navbar <- renderUI({

            if(!global.param$analysis.run) return()

            ##############################################
            ## determine the number of group comparisons,
            ## e.g. for the number of volcano plots to draw
            ##############################################
            groups.comp <- unique(global.param$grp.comp)

            ################################################################################################################
            ##
            ##                           define the different tabs shown in the navigation bar
            ##
            ################################################################################################################

            ###############################################################
            ## EXPORT tab
            ## - export all figures/tables at once and generate a zip file
            ## - download the zip file
            ###############################################################
            export.tab <- tabPanel('Export',
                                   if(!(global.results$export.results)){
                                       fluidPage(
                                           fluidRow( column(3, h4('Specify what to export:')), column(9)), ##column(3, checkboxInput('export.all', '(un)check all', value=T)), column(3)),
                                           fluidRow(
                                               column(3), column(3, checkboxInput('export.hm', 'Heatmap',value=T)), column(3, checkboxInput('export.box', 'Boxplots',value=T)), column(3)
                                           ),
                                           fluidRow(
                                               column(3), column(3, checkboxInput('export.volc', 'Volcano plot',value=T)), column(3, checkboxInput('export.phist', 'P-value histogram',value=T)), column(3)
                                           ),
                                           fluidRow(
                                               column(3), column(3, checkboxInput('export.pca', 'PCA',value=T) ), column(3, checkboxInput('export.ms', 'Multiscatter',value=T)), column(3)
                                           ),
                                           fluidRow(column(3), column(3, checkboxInput('export.excel', 'Excel sheet',value=T)), column(3, checkboxInput('export.cm', 'Correlation matrix',value=T)), column(3)),
                                           fluidRow(column(3), column(3, checkboxInput('export.profile', 'Profile plot',value=T)),  column(6)),
                                           tags$br(),
                                           tags$hr(),
                                           tags$br(),
                                           fluidRow(column(3, h4('Export results:')), column(3, actionButton('export.results', 'Export (.zip)')), column(6))
                                       )
                                   } else {
                                       fluidPage(
                                           fluidRow(column(3, h4('Specify what to export:')), column(9)),
                                           fluidRow(
                                               column(3), column(3, checkboxInput('export.hm', 'Heatmap',value=T)), column(3, checkboxInput('export.box', 'Boxplots',value=T)), column(3)
                                           ),
                                           fluidRow(
                                               column(3), column(3, checkboxInput('export.volc', 'Volcano plot',value=T)), column(3, checkboxInput('export.phist', 'P-value histogram',value=T)), column(3)
                                           ),
                                           fluidRow(
                                               column(3), column(3, checkboxInput('export.pca', 'PCA',value=T) ), column(3, checkboxInput('export.ms', 'Multiscatter',value=T)), column(3)
                                           ),
                                           fluidRow(column(3), column(3, checkboxInput('export.excel', 'Excel sheet',value=T)), column(3, checkboxInput('export.cm', 'Correlation matrix',value=T)), column(3)),
                                           tags$br(),
                                           tags$hr(),
                                           tags$br(),
                                           fluidRow(column(3, h4('Export results:')), column(3, actionButton('export.results', 'Export (.zip)')), column(6)),
                                           tags$br(),
                                           tags$br(),
                                           fluidRow(column(3, h4('Download results:')), column(3, downloadButton('download.results', 'Download (.zip)')), column(6)),
                                           tags$br()
                                       )

                                   }
                                   )

            ############################################
            ## SUMMARY
            ##    some general numbers on the
            ##    uploaded data
            ##
            ############################################
            summary.tab <-  tabPanel('Summary',
                                    fluidPage(
                                        fluidRow(
                                            column(12, h4('Dataset:'))
                                        ),
                                        fluidRow(
                                             column(12, align='center',  tableOutput('summary.data'))
                                        ),
                                        tags$hr(),
                                        fluidRow(
                                             column(12, h4('Workflow:'))
                                        ),
                                        fluidRow(
                                             column(12, align='center',  tableOutput('summary.workflow'))
                                        ),
                                        tags$hr(),
                                        fluidRow(
                                             column(12, h4('Test results:'))
                                        ),
                                        fluidRow(
                                             column(12, align='center',  tableOutput('summary.test'))
                                        ),
                                        tags$hr(),
                                        fluidRow(
                                            column(12, h4('Non-missing values:'))
                                        ),
                                        fluidRow(
                                             column(12, align='center',  plotlyOutput('summary.nonmissing.data'))
                                        ),
                                        tags$hr(),
                                        fluidRow(
                                            column(12, h4('Missing values:'))
                                        ),
                                        fluidRow(
                                             column(12, align='center',  plotlyOutput('summary.missing.data.row'))
                                        )


                                    )
                                  )

            ############################################
            ## VOLCANO
            ##      tabs for the volcano plots
            ## NOT for F test
            ############################################
           ## if(global.param$which.test != 'mod F'){
                volc.tabs <- list()
                volc.tabs[[1]] <- 'Volcanos'
                for(i in 1:length(unique(groups.comp))){
                    volc.tabs[[i+1]]=tabPanel(paste0( groups.comp[i] ),

                                          fluidPage(
                                              fluidRow(
                                                  column(2, numericInput( paste("cex.volcano",groups.comp[i], sep='.'), "Point size", value=2, min=1, step=1)),
                                                  ##column(1, numericInput( paste("opac.volcano",groups.comp[i],sep='.'), "Opacity %", value=50, min=0, max=100, step=10)),
                                                  column(2, numericInput( paste("cex.volcano.lab",groups.comp[i],sep='.'), "Label size", value=1, min=.1, step=.1)),
                                                  column(2, selectInput( paste("grid.volcano",groups.comp[i],sep='.'), "Grid", c(T, F), selected=T)),
                                                  column(2, numericInput("max.logP", "Max. Log10(P-value)", value=100, min=20, max=100, step=10) ),
                                                  column(4)##,
                                                  ##column(1, downloadButton(paste('downloadVolcano', groups.comp[i],sep='.'), 'Download (pdf)'))
                                              ),
                                              tags$br(),
                                              tags$hr(),
                                              tags$br(),
                                              fluidRow(
                                                  column(12, align='center', tableOutput(paste('info',groups.comp[i], sep='.')))
                                              ),
                                              fluidRow(
                                                  column(9, align='center',
                                                         plotOutput( paste("volcano",groups.comp[i], sep='.'), width=800, height=800, click=paste('plot_click', groups.comp[i], sep='.'), hover=hoverOpts(id=paste('plot_hover', groups.comp[i], sep='.'), delay=10) )),
                                                  column(3, tableOutput(paste('volc.tab.selected', groups.comp[i], sep='.')))
                                              )
                                          )
                                        ) ## end tabPanel
                } ## end for i
           ## } ## end if not mod F

            ############################################
            ## HEATMAP
            ##
            ############################################
            hm.tab <-  tabPanel('Heatmap',
                                    fluidPage(
                                        fluidRow(
                                            column(2, h4('Column labels')),
                                            column(2, h4('Row labels')),
                                            column(8)
                                            ##column(9),
                                            ##column(1, h4('Export'))
                                        ),
                                        fluidRow(
                                            column(2, numericInput( "cexCol", "Size", value=12, min=1, step=1)),
                                            column(2, numericInput( "cexRow", "Size", value=8, min=1, step=1)),
                                            column(2, selectInput( "hm.scale", "Scale", c("row","column","none"), selected="none")),
                                            column(2, selectInput( "hm.clust", "Cluster", c("column","row","both","none"), selected=ifelse(global.param$which.test != "mod F", "none" ,"both"))),
                                            ##column(2),
                                            column(1, checkboxInput('hm.max', 'Cap values', value=FALSE)),
                                            column(2, numericInput( "hm.max.val", "Max. value", value=4, step=1, min=2)),
                                            ##column(2),
                                            ##column(1, downloadButton('downloadHM', 'Download (pdf)'))
                                            column(1)
                                        ),
                                        tags$br(),
                                        tags$hr(),
                                        tags$br(),
                                        fluidRow(
                                            column(12, align='center', plotOutput("HM") )
                                        ),
                                        tags$br(),
                                        tags$hr(),
                                        tags$br()
                                    )
                                )

            #############################################
            ## PCA
            ##
            #############################################
            pca.tab <- tabPanel('PCA',
                                     fluidPage(
                                         ##fluidRow( column(12, tags$h3('Principle component analysis:')) ),
                                         ## fluidRow(column(2, selectInput('pca.x', 'x-axis', paste('PC', 1:nrow(global.results$data))), selected='PC 1'), column(2, selectInput('pca.y', 'y-axis', paste('PC', 1:nrow(global.results$data)), selected='PC 2')), column(8) ),
                                         fluidRow(column(2, selectInput('pca.x', 'x-axis', paste('PC', 1:10)), selected='PC 1'), column(2, selectInput('pca.y', 'y-axis', paste('PC', 1:10), selected='PC 2')), column(2, selectInput('pca.z', 'z-axis', paste('PC', 1:10), selected='PC 3')), column(6) ),
                                         fluidRow(column(12, align='center', plotlyOutput("pcaxy.plotly", width=600, height=600))),
                                         tags$hr(),
                                         fluidRow(column(12, align='center', plotlyOutput("pcaxyz.plotly", width=800, height=800)) ),
                                         tags$br(),
                                         tags$hr(),
                                         tags$br(),
                                         fluidRow( column(12, h3('Static figure:'))),
                                         ##fluidRow( column(1, h4('Export')),  column(10)),
                                         ##fluidRow( column(1, downloadButton('downloadPCA', 'Download (pdf)')), column(11) ),
                                         fluidRow( column(12, align='center', plotOutput("pca", width=1200, height=400) ) ),

                                         tags$br(),
                                         tags$hr()
                                     )
                                )

            #############################################
            ## TABLE
            ##
            #############################################
            table.tab <- tabPanel('Table',
                     fluidPage(
                         ##fluidRow(column(8, tags$h3('Result table (filtered):')), column(4, downloadButton('downloadExcel', 'Download (Excel)') )),
                         fluidRow(column(12, tags$h3('Result table (filtered):'))),
                         fluidRow(column(12, tags$br())),
                         fluidRow(column(12, dataTableOutput("tableprev")))
                     )
                     )
            #############################################
            ## QC
            ##
            #############################################
            qc.tabs <- vector('list', 5)
            names(qc.tabs) <- c('Boxplots', 'P-values', 'Multi scatter', 'Correlation matrix', 'Correlation matrix transposed')

            ###########################
            ## boxplots
            qc.tabs[['Boxplots']] <- tabPanel('Boxplots',
                                              fluidPage(
                                                  fluidRow( column(12, plotOutput("expr.boxplot", width=1200, height=max( 30*(ncol( global.input$table)+2), 500)))),
                                                  tags$br(),tags$hr(),tags$br(),
                                                  if(!is.null(global.results$table.norm)) fluidRow(column(12, plotOutput("expr.boxplot.norm", width=1200, height=max( 30*(ncol( global.input$table)+2), 500)))),
                                                  tags$br()
                                              )
                                              )
            ###########################
            ## profile plots
            qc.tabs[['Profile plots']] <- tabPanel('Profile plots',

                                                       if(is.null(global.results$table.norm)){
                                                           fluidPage(
                                                               tags$br(),
                                                                fluidRow( column(12, plotOutput("expr.profile", width=600, height=600)))
                                                            )
                                                       } else {
                                                           fluidPage(
                                                               tags$br(),
                                                               fluidRow(
                                                                   column(6, plotOutput("expr.profile", width=600, height=600)),
                                                                   column(6, plotOutput("expr.profile.norm", width=600, height=600))
                                                               )
                                                           )
                                                       }
                                                   )

            ###########################
            ## P-value distribution
            qc.tabs[['P-values']] <- tabPanel('P-values',
                                              fluidPage(
                                                  fluidRow(
                                                      column(12, plotOutput("pval.hist"))
                                                  )
                                              )
                                              )
            ############################
            ## correlation multiscatter
            qc.tabs[['Multi scatter']] <- tabPanel('Multi scatter',
                                                  fluidPage(
                                                      column(2, checkboxInput('ms.max', 'Define limits', value=plotparams$ms.max)),
                                                      column(2, numericInput( "ms.min.val", "min.", value=plotparams$ms.min.val, step=1)),
                                                      column(2, numericInput( "ms.max.val", "max.", value=plotparams$ms.max.val, step=1)),
                                                      ##column(8),
                                                      ##column(1, downloadButton('downloadMS', 'Download (pdf)'))
                                                      column(6)
                                                  ),
                                                  tags$br(),tags$hr(),tags$br(),
                                                  fluidPage(
                                                      fluidRow(
                                                          column(12, plotOutput("multi.scatter"))                                                      )
                                                  )
                                                  )

             ###########################
             ## correlation matrix
             qc.tabs[['Correlation matrix']] <- tabPanel('Correlation matrix',

                                                         fluidPage(
                                                             fluidRow(
                                                                 column(3,  selectInput( "cm.upper", "Upper triangle", c("pearson","spearman","kendall"), selected="pearson")),
                                                                 column(3,  selectInput( "cm.lower", "Lower triangle", c("pearson","spearman","kendall"), selected="spearman")),
                                                                 column(1,  checkboxInput('cm.numb', 'Show numbers', value=TRUE)),
                                                                 column(5)
                                                             )##,
                                                             ##fluidRow(
                                                             ##    column(11),
                                                             ##    column(1, downloadButton('downloadCM', 'Download (pdf)'))
                                                             ##)
                                                         ),
                                                         tags$br(),tags$hr(),tags$br(),
                                                         fluidPage(
                                                             fluidRow(
                                                                 column(12, plotOutput("correlation.matrix"))
                                                             )
                                                         )
                                                         )
             ###########################
             ## correlation matrix
             qc.tabs[['Correlation matrix transposed']] <- tabPanel('Correlation matrix transposed',

                                                         fluidPage(
                                                             fluidRow(
                                                                 column(1,  selectInput( "cm.upper", "Upper triangle", c("pearson","spearman","kendall"), selected="pearson")),
                                                                 column(1,  selectInput( "cm.lower", "Lower triangle", c("pearson","spearman","kendall"), selected="spearman")),
                                                                 column(1,  checkboxInput('cm.numb', 'Show numbers', value=FALSE)),
                                                                 column(9)
                                                             ),
                                                             fluidRow(
                                                                 column(11),
                                                                 column(1, downloadButton('downloadCMtrans', 'Download (pdf)'))
                                                             )
                                                         ),
                                                         tags$br(),tags$hr(),tags$br(),
                                                         fluidPage(
                                                             fluidRow(
                                                                 column(12, plotOutput("correlation.matrix.trans"))
                                                             )
                                                         )
                                                         )



            ###################################################################################
            ##
            ##                         insert the tabs
            ##
            ###################################################################################
             navbarPage(title='', id='mainPage',

                        ##if(!is.null(error$msg)) return(),
                        #######################################
                        ##            insert summary tab
                        #######################################
                        summary.tab,
                        #######################################
                        ##              insert heatmap
                        #######################################
                        hm.tab,
                        #######################################
                        ##              insert volcanos
                        #######################################
                        if( !(global.param$which.test %in% c('mod F', 'none'))){
                           ##cat('test volc ins\n')
                           do.call(navbarMenu, volc.tabs)
                       } else {
                           ''
                       },
                       #######################################
                       ##              insert PCA
                       #######################################
                       pca.tab,

                       #######################################
                       ##           insert table preview
                       #######################################
                       table.tab,

                       #######################################
                       ## QC
                       if(global.param$which.test == 'none'){
                           ##qc.what <- c('Boxplots', 'Multi scatter', 'Correlation matrix', 'Correlation matrix transposed')
                           qc.what <- c('Boxplots', 'Profile plots', 'Multi scatter', 'Correlation matrix')
                       } else {
                           qc.what <- c('Boxplots',  'Profile plots', 'P-values', 'Multi scatter', 'Correlation matrix')
                           ##qc.what <- names(qc.tabs)
                       },
                       do.call(navbarMenu, append("QC", qc.tabs[ qc.what ])),

                       #########################################
                       ## export
                       export.tab
                       ) ## end navbarpage
        })

        #########################################################################################
        ##
        ##                                  user input
        ##
        #########################################################################################

        ######################################
        ## 1) file upload
        output$file.upload <- renderUI({

            if(!is.null(input$file)) return()
            if(!is.null( global.input$file)) return()

            ##########################################
            ## upload form
            list(
                HTML('<font size=\"3\"><b>Upload file:</b></font>'),
                fileInput("file", "", accept=c('text/csv',
                       'text/comma-separated-values,text/plain',
                       '.csv', '.txt', '.tsv')),
                HTML('<hr border-width:\"10px\">')
            )
        })

        ######################################
        ## import session
        output$import.session <- renderUI({

            if(!is.null(input$file)) return()
            if(!is.null( global.input$file)) return()

            ## upload form
            list(
                HTML('<font size=\"3\"><b>Import previously saved session:</b></font>'),
                fileInput("session.import", "", accept=c('.RData')),
                HTML('<hr border-width:\"10px\">')
            )

        })

        ######################################
        ## 3) pick id column
        output$choose.id.column <- renderUI({

            if(global.param$analysis.run) return()

            if(is.null(global.input$table)) return()
            if(!is.null(input$id.col))
                if(input$id.col > 0 && !is.null(input$id.col.value)) return()
            ##if(!is.null(global.input$id.col))
            ##    if(global.input$id.col > 0 && !is.null(global.input$id.col.value)) return()

            ## get uploaded table and column names
            tab <- global.input$table
            tab.colnames <- global.input$table.colnames

            ## try to find 'id' and move it to the first position
            id.idx <- grep('id|ID', tab.colnames)
            if(length(id.idx) > 0){
                tab.colnames <- c(tab.colnames[id.idx], tab.colnames[-id.idx])
            }

            ## radio button to pick id column
            list(
                ## experimental design
                downloadButton("exportTemplate", 'Export experimental design template'),
                HTML('<br><hr size=\"5\">'),
                radioButtons( "id.col.value", "Choose ID column", tab.colnames),
                actionButton("id.col", 'OK')
            )

        })

        ######################################
        ## 5) define groups
        output$define.groups <- renderUI({

            if(is.null(input$id.col)) return() ## no id colum
            if( !is.null(input$id.col))
                if( input$id.col == 0 ) return() ## not pressed yet
            if(!is.null(global.results$data)) return() ## test has been run
            if(!is.null(global.param$grp)){            ## group assignment has been RUN
                if(sum(is.na(global.param$grp)) == 0) return() ## group assignemnt has been DONE
            }

            ## number of assigned groups
            N.grp = global.param$N.grp + 1

            list(
                ## upload template
                fileInput("exp.file", "Upload experimental design file", accept=c('text/plain','.txt')),
                actionButton( 'update.grp', 'Next')
            )
        })

        ######################################
        ## filter type
        output$filter.type <- renderUI({
            if(!global.param$analysis.run) return()

            if(global.param$which.test != 'none')
                list(selectInput('filter.type', 'Filter based on:', c('nom.p', 'adj.p', 'top.n', 'none'), selected=ifelse(global.param$which.test == 'none', 'none', global.param$filter.type)))
            else
                list(selectInput('filter.type', 'Filter based on:', c('none'), selected='none'))
        })

        #####################################
        ## export session
        ##output$export.session <- renderUI({
        ##    if(!global.param$analysis.run) return()
        ##
        ##    list(HTML('<b>Export session</b></br>'),
        ##         actionButton('save.session', 'Export (.RData)')
        ##         )
        ##})

        #####################################
        ## export analysis results
        output$export.all.results <- renderUI({
            if(!global.param$analysis.run) return()

            list(HTML('<b>Export ALL results</b></br>'),
                 actionButton('export.results', 'Export (.zip)')
                 )
        })



        #####################################
        ## 6) select test
        output$list.groups <- renderUI({

            if( !global.param$grp.done ) return()

            list(
                radioButtons('log.transform', 'Log-transformation', choices=c('none', 'log10', 'log2'), selected=global.param$log.transform),
                radioButtons('norm.data', 'Data normalization', choices=c('Median', 'Median-MAD', '2-component', 'Quantile', 'none'), selected=global.param$norm.data),
                radioButtons('repro.filt', 'Reproducibility filter (beta)', choices=c('yes', 'no'), selected=global.param$repro.filt),
                radioButtons('which.test', 'Select test', choices=c('One-sample mod T', 'Two-sample mod T', 'mod F', 'none'), selected=global.param$which.test),

                actionButton('run.test', 'Run analysis!')
            )
        })

        ################################################
        ##             export session
        ################################################
        observeEvent(input$save.session, {

            global.input.imp <- lapply(global.input, unclass)
            global.param.imp <- lapply(global.param, unclass)
            global.results.imp <- lapply(global.results, unclass)
            volc.imp <-  lapply(volc, unclass)



            plotparams.imp <- list(
                ## multiscatter
                ms.max=input$ms.max,
                ms.min.val=input$ms.min.val,
                ms.max.val=input$ms.max.val
           )

            ## save as R-object
            ##save(global.input.imp, global.param.imp, global.results.imp, plotparams.imp, volc.imp, file=paste(global.param$session, '.RData', sep=''))
            save(global.input.imp, global.param.imp, global.results.imp, plotparams.imp, volc.imp, file=paste(global.param$session.dir, 'session.RData', sep='/'))
        })

        #############################################################################
        ##
        ##       export all analysis results
        ## - generate a zip-file
        #############################################################################
        observeEvent(input$export.results, {

            ##cat('User:', session$user, '\n')
            if(!is.null(error$msg)) return()

            ###############################
            ## apply filter
            filter.res()
            res = global.results$filtered

            #######################################
            ## extract expression values
            res = res[, names(global.param$grp)]

            ## groups to compare
            grp.comp <- unique( global.param$grp.comp )


            ##############################################################
            ##
            ##withProgress('Exporting', {

            #############################################################
            ##                correlation matrix
            #############################################################
            if(input$export.cm){
                withProgress(message='Exporting', detail='correlation matrix',{
                fn.cm <- paste(global.param$session.dir, '/correlation_matrix_lo_',input$cm.lower, '_up_',input$cm.upper, '.pdf', sep='')
                ##plotCorrMat(lower=input$cm.lower, upper=input$cm.upper, display_numbers=F, filename=fn.cm)
                ##pdf(file, height=1000*(11/800), width=1200*(11/800))
                plotCorrMat(lower=input$cm.lower, upper=input$cm.upper, display_numbers=F, filename=fn.cm)

                })
            }
            ############################################################
            ##                   volcanos
            ############################################################
            if(input$export.volc){
                withProgress(message='Exporting', detail='volcano plot',{
                fn.volc <- paste(global.param$session.dir, 'volcano.pdf', sep='/')


                    pdf(fn.volc, height=11, width=11)
                    for(j in 1:length(grp.comp)){
                        local({
                            my_j=j
                            plotVolcano(grp.comp[my_j], max.logP=input$max.logP)
                        })
                    }
                dev.off()
                })
            }
            ############################################################
            ##                 PCA
            ############################################################
            if(input$export.pca){
                withProgress(message='Exporting', detail='pca',{
                fn.volc <- paste(global.param$session.dir, 'pca.pdf', sep='/')
                pdf(fn.volc, height=5, width=15)
                pca=plotPCA()
                dev.off()
                })
            }
            ############################################################
            ##                    boxplots
            ############################################################
            if(input$export.box){
                withProgress(message='Exporting', detail='box plot',{
                    fn.box <- paste(global.param$session.dir, 'boxplots_unnormalized.pdf', sep='/')

                    ###############################################
                    ## unnormalized ratios
                    if(is.null(global.results$table.log))
                        tab <- data.frame(global.input$table)
                    else
                        tab <- data.frame(global.results$table.log)

                    ## id column
                    id.col.value <- global.param$id.col.value
                    ## group vector
                    grp <- global.param$grp
                    ## group colors
                    grp.col <- global.param$grp.colors
                    grp.col.leg <- global.param$grp.colors.legend

                    ## pdf
                    pdf(fn.box, 12, max(3, .8*ncol(global.input$table)))
                    makeBoxplot(tab, id.col.value, grp, grp.col, grp.col.leg)
                    dev.off()

                    ################################################
                    ## normalized
                    if(!is.null(global.results$table.norm) ){
                        fn.box <- paste(global.param$session.dir, paste('boxplots_', global.param$norm.data,'.pdf', sep=''), sep='/')
                        ## normalized ratios
                        tab <- data.frame(global.results$table.norm)
                        ## pdf
                        pdf(fn.box, 12, max(3, .8*ncol(global.input$table)))
                        makeBoxplot(tab, id.col.value, grp, grp.col, grp.col.leg)
                        dev.off()
                    }
                })
            }

            ############################################################
            ##                profile plots
            ############################################################
             if(input$export.profile){
                withProgress(message='Exporting', detail='profile plot',{
                    fn.profile <- paste(global.param$session.dir, 'profile_plot.pdf', sep='/')

                    ###############################################
                    ## unnormalized ratios
                    if(is.null(global.results$table.log))
                        tab <- data.frame(global.input$table)
                    else
                        tab <- data.frame(global.results$table.log)

                    ## id column
                    id.col.value <- global.param$id.col.value
                    ## group vector
                    grp <- global.param$grp
                    ## group colors
                    grp.col <- global.param$grp.colors
                    grp.col.leg <- global.param$grp.colors.legend

                    ################################################
                    ## normalized
                    if(!is.null(global.results$table.norm) ){
                        pdf(fn.profile, 14, 7)
                        par(mfrow=c(1,2))
                        ## normalized ratios
                        tab.norm <- data.frame(global.results$table.norm)
                        makeProfileplot(tab, id.col.value, grp, grp.col, grp.col.leg, main='unnormalized')
                        makeProfileplot(tab.norm, id.col.value, grp, grp.col, grp.col.leg, main=paste(global.param$data.norm, 'normalized'))
                        dev.off()
                    } else{
                        pdf(fn.profile, 7, 7)
                        par(mfrow=c(1,2))
                        makeProfileplot(tab, id.col.value, grp, grp.col, grp.col.leg, main='unnormalized')
                        dev.off()

                    }
                })
            }

            ############################################################
            ##                 multi scatter
            ############################################################
            if(input$export.ms){
                withProgress(message='Exporting', detail='multiscatter',{
                fn.ms <- paste(global.param$session.dir, 'multiscatter.pdf', sep='/')
                pdf(fn.ms, height=120*ncol(global.input$table)*(11/800), width=120*ncol(global.input$table)*(11/800))
                plotMultiScatter( define.max=input$ms.max, min.val=input$ms.min.val, max.val=input$ms.max.val )
                dev.off()
                })
            }

            ############################################################
            ##                   p-values
            ############################################################
            if(input$export.phist){
                withProgress(message='Exporting', detail='p-value histogram',{
                fn.pval <- paste(global.param$session.dir, 'histogram_P-values.pdf', sep='/')

                ## unfiltered results
                res.all = global.results$data$output

                pdf(fn.pval, 10, 5*ifelse( global.param$which.test != 'mod F', length(grp.comp), 1 ))

                ############################################
                ## mod T
                if(global.param$which.test != 'mod F'){
                    par(mfrow=c(length(grp.comp),1))
                    for(g in grp.comp){
                        pval <- res.all[, paste('P.Value', g, sep='.')]
                        hist(pval, breaks=50, main=paste('Histogram of P-values (N=', sum(!is.na(pval)), ')',sep=''), xlab='P-value', cex.main=2.2, cex.axis=2, cex.lab=2, col='darkblue', border=NA)
                        legend('top', legend=g, cex=2)
                    }
                 ############################################
                 ## mod F
                } else {
                    pval <- res.all[, paste('P.Value')]
                    hist(pval, breaks=50, main=paste('Histogram of P-values (N=', sum(!is.na(pval)), ')',sep=''), xlab='P-value', cex.main=2.2, cex.axis=2, cex.lab=2, col='darkblue', border=NA)
                    ## legend('top', legend=paste(groups), cex=2)
                }
                dev.off()
                })

            }

            ############################################################
            ##                   heatmap
            ## require at least three significant hits
            ############################################################
            if(input$export.hm){
                if(nrow(res) >= 3){
                    withProgress(message='Exporting', detail='heatmap',{
                    fn.hm <- paste(global.param$session.dir, 'heatmap.pdf', sep='/')
                    ## heatmap title
                    hm.title <- paste('filter:', global.param$filter.type, ' / cutoff:', global.param$filter.value, sep='')
                    hm.title <- paste(hm.title, '\nsig / total: ', nrow(res), ' / ', nrow( global.results$data$output ), sep='')

                    if(input$hm.max){
                        plotHM(res=res, grp=global.param$grp, grp.col=global.param$grp.colors, grp.col.legend=global.param$grp.colors.legend,  hm.clust=input$hm.clust, hm.title=hm.title, hm.scale=input$hm.scale, cellwidth=ifelse(ncol(res)<40, 40, 20), fontsize_row=input$cexRow, fontsize_col=input$cexCol, max.val=input$hm.max.val, style=global.param$which.test, filename=fn.hm, cellheight=min( dynamicHeightHM( nrow(global.results$filtered)), 1500 )/nrow(global.results$filtered))

                    } else {
                        plotHM(res=res, grp=global.param$grp, grp.col=global.param$grp.colors, grp.col.legend=global.param$grp.colors.legend,  hm.clust=input$hm.clust, hm.title=hm.title, hm.scale=input$hm.scale, cellwidth=ifelse(ncol(res)<40, 40, 20), fontsize_row=input$cexRow, fontsize_col=input$cexCol, style=global.param$which.test, filename=fn.hm, cellheight= min( dynamicHeightHM( nrow(global.results$filtered)), 1500 )/nrow(global.results$filtered), max.val=input$hm.max.val)
                    }
                    })
                } ## end if nrow(res)>3

            }

            #########################################################
            ##               Excel sheet
            #########################################################
            if(input$export.excel){
                withProgress(message='Exporting', detail='Excel sheet',{
                    res.comb <- global.results$data$output
                    tmp <- sort(global.param$grp)

                    ## append annotation columns
                    if(!is.null(global.input$table.anno))
                        res.comb <- cbind(res.comb, Annotation.starts.here=rep('', nrow(res.comb)), global.input$table.anno)
                    expDesign <- data.frame(Column=names(tmp), Experiment=tmp)

                    ## generate_filename
                    fn.tmp <- sub(' ','_', paste(global.param$session.dir, '/', 'results_', sub(' ', '_',global.param$which.test),  ifelse(global.param$log.transform != 'none', paste('_', global.param$log.transform, sep=''), '_'), ifelse(global.param$norm.data != 'none', paste('_', global.param$norm.data, sep=''), '_'), ifelse(input$repro.filt=='yes', paste('_reprofilt', sep=''), '_'), sub(' .*', '', Sys.time()),".xlsx", sep=''))
                    global.param$ExcelFileName <- fn.tmp
                    ## Excel
                    WriteXLS(c('res.comb', 'expDesign'), ExcelFileName=fn.tmp, FreezeRow=1, FreezeCol=1, SheetNames=c('modT', 'class vector'), row.names=F, BoldHeaderRow=T, AutoFilter=T)

                })
            }

            #########################################################
            ##                  session
            #########################################################
            ##global.input.imp <- lapply(global.input, unclass)
            ##global.param.imp <- lapply(global.param, unclass)
            ##global.results.imp <- lapply(global.results, unclass)
            global.input.imp <- reactiveValuesToList(global.input)
            global.param.imp <- reactiveValuesToList(global.param)
            global.results.imp <- reactiveValuesToList(global.results)

            ## volcano coordinates
            ##volc.imp <-  lapply(volc, unclass)
            volc.imp <-  reactiveValuesToList(volc)

            ## plotting params
            plotparams.imp <- list(
                ## multiscatter
                ms.max=input$ms.max,
                ms.min.val=input$ms.min.val,
                ms.max.val=input$ms.max.val
            )
            ## save as R-object
            save(global.input.imp, global.param.imp, global.results.imp, plotparams.imp, volc.imp, file=paste(global.param$session.dir, 'session.RData', sep='/'))


            #########################################################
            ##   export parameters as small text file
            #########################################################
            params <- global.param.imp[c('log.transform', 'norm.data', 'repro.filt' , 'which.test', 'filter.type', 'filter.value')]

            params.txt <- unlist(lapply(params, paste, collapse=';'))
            params.txt <-  paste(names(params.txt),params.txt, sep='\t')

            ## hostname
            params.txt <- c(paste('## hostname: ', session$clientData$url_hostname, sep=''), '' , params.txt)

            ## session id
            params.txt <- c(paste('##', global.param$session ), params.txt)

            ## version
            params.txt <- c(paste('## ', APPNAME, ' (v', VER, ')', sep='') , params.txt)

            ## add date and time
            params.txt <- c(paste('##', as.character(Sys.time())), params.txt)

            ## export
            writeLines(params.txt, con=paste(global.param$session.dir, 'params.txt', sep='/'))

            ##############################################################
            ##            create an archive
            ##############################################################
            ##fn.zip <- paste(global.param$session.dir, '/results.zip', sep='')
            ##fn.all <- grep('pdf$|xlsx$|RData$|txt$',  dir(global.param$session.dir, full.names=T) , value=T)
            ##system( paste('zip -0 ', fn.zip, ' ', paste(fn.all, collapse=' '), sep='') )
            ## timestamp as filename
	    fn.zip <- paste( gsub('\\:', '', gsub(' ','-', gsub('-','',Sys.time()))),'.zip', sep='')
            ## file names to zip
	    fn.all <- grep('pdf$|xlsx$|RData$|txt$',  dir(global.param$session.dir) , value=T)
	    fn.all.abs <- grep('pdf$|xlsx$|RData$|txt$', dir(global.param$session.dir, full.names=T), value=T)
            ## run command
	    if(OS == 'Windows')
                system( paste('zip -0 ', paste(global.param$session.dir, fn.zip, sep='/'), ' ', paste(fn.all.abs, collapse=' '), sep='') )
            else
                system( paste('cd ',global.param$session.dir,' && zip -0 ', fn.zip, ' ', paste(fn.all, collapse=' '), sep='') )
            ## store file.name
	    global.param$zip.name=fn.zip
            ## cat('test16\n')

             ###############################################################
             ## remove archived files
             ##file.remove(paste(global.param$session.dir, fn.all, sep=''))
	     file.remove(fn.all.abs)

             ###############################################################
             ## flag export
             global.results$export.results=T

	     ##cat(file=stderr(),'\n\n', paste(global.param$session.dir, global.param$zip.name, sep=''), '\n\n' )

             ## redirect to the same panel
             updateTabsetPanel(session, 'mainPage', selected='Export')
        })


        ################################################################################################
        ##
        ##                             Do the actual computation
        ##
        ################################################################################################

        ###############################################
        ## 4) initialize group assignemnt
        observeEvent( input$id.col ,{

            if( is.null( global.input$table) | is.null(input$id.col.value) ) return()

            #############################################
            ## check the id column
            tab <- global.input$table
            ## make sure the ids are unique
            ids <- make.unique(as.character(tab[, input$id.col.value]), sep='_')
            tab[, global.input$id.col.value] <- ids
            rownames(tab) <- ids

            ########################################
            ## store
            global.input$table <-  tab


            #############################################
            ## initialize group assignemnt
            groups <- rep(NA, ncol(global.input$table))
            names(groups) <- colnames(global.input$table)

            ## remove id column
            groups <- groups[-c( which(input$id.col.value == names(groups))) ]

            ## set group assingment
            global.param$grp <- groups
            ## set number of assinged groups
            global.param$N.grp <- 0
        })

        #################################################################################
        ##
        ## 2) upload file
        ##    session id is generated here
        #################################################################################
        observeEvent( input$file, {

            ########################################
            ## generate session ID and prepare data
            ## directory
            #########################################
            ## generate 'session id'
            if(is.null(global.param$session))
                global.param$session <- paste(paste(letters[sample(26, 5)], collapse=''), paste(sample(100,5), collapse=''), sep='')

            ## create directory on server to store the results
            dir.create(paste(DATADIR, global.param$session, sep=''))
            global.param$session.dir <- paste(DATADIR, global.param$session, sep='')



            ##################################
            ## determine the separator
            tab.sep=NULL
            ## try to figure out the separator, DON'T USE THE HEADER FOR THAT
            ## use the fourth row instead (should be data)
            for(s in SEPARATOR){
                tab <- read.table(input$file$datapath, sep=s, header=T, stringsAsFactors=F, nrows=1, skip=3)
                ##tab <- tab[nrow(tab), ]
                if(length(tab) > 1){
                    global.param$tabsep <- s
                    break;
                }
            }
            ###########################################################
            ## import the table
            if( global.param$tabsep == '\t'){
                tab <- read.delim( input$file$datapath, stringsAsFactors=F, na.strings=NASTRINGS)
            } else {
                tab <- read.table( input$file$datapath, sep=global.param$tabsep, header=T, stringsAsFactors=F, na.strings=NASTRINGS, quote = "\"", dec = ".", fill = TRUE, comment.char = "")
            }

            ## shorten column names and store together with the original names
            colnames.tmp <- chopString(colnames(tab), STRLENGTH)
            names(colnames.tmp) <- colnames(tab)

            ## store values
            global.input$table <- global.input$table.org <- tab
            global.input$file <- input$file
            global.input$table.colnames <- colnames.tmp

            rm(tab, colnames.tmp)
        })

        #################################################################
        ##
        ##                import session
        ##
        #################################################################
        observeEvent(input$session.import, {

            #################################
            ## import workspace
            load( input$session.import$datapath )

            #################################
            ## assign the importes values to the global reactive variables
            for(i in names(global.input.imp)){
                global.input[[i]] <- global.input.imp[[i]]
            }
            for(i in names(global.param.imp)){
                global.param[[i]] <- global.param.imp[[i]]
                ##cat(i,'\t',global.param[[i]], '\n')
            }
            for(i in names(global.results.imp)){
                global.results[[i]] <- global.results.imp[[i]]
            }
            for(i in names(plotparams.imp)){
                plotparams[[i]] <- plotparams.imp[[i]]
            }
            for(i in names(volc.imp)){
                volc[[i]] <- volc.imp[[i]]
            }
            ##################################
            ## set flags
            global.param$session.imported=T
            global.param$analysis.run=T
            global.results$export.results=F

            ##################################
            ## clean up
            rm(global.input.imp, global.param.imp, global.results.imp, plotparams.imp, volc.imp)

            ###################################################################
            ##            insert the panels for the volcanos
            ###################################################################
            if(!(global.param$which.test %in% c('mod F', 'none'))){
                ins.volc()
            }
        })

        #################################################################
        ## 4c)       upload experimental design file
        ##
        ## - divide input table into expression and annotation columns
        observeEvent( input$exp.file, {

            ## reset error message
            error$msg <- NULL

            ## read the file
            grp.file <- read.delim(input$exp.file$datapath, header=T, stringsAsFactors=F)
            Column.Name <- grp.file$Column.Name
            Experiment <- grp.file$Experiment

            ###############################################################
            ## index on non-empty 'Experiment' rows
            exprs.idx <- which(nchar(Experiment) > 0 )

            ###############################################################
            ##
            ##                   do some sanity checks
            ##
            ###############################################################

            ## names in the exp design file do not match to the table
            if( sum( Column.Name != colnames(global.input$table)) > 0 ){
                error$msg <- 'Experimental design files does not match the table you have uploaded!'
                return()
            }

            ## not an experimental design file
            if( sum( colnames(grp.file) %in% c('Column.Name', 'Experiment'), na.rm=T) != 2 )  {
                error$msg <- 'This is not an experimental desgin file!\n\nThe file should contain two columns (Column.Name, Experiment)!'
                return()
            }
            ## 'empty' file
            if( sum( nchar(Experiment) > 0 ) == 0 | sum(!is.na( Experiment) == 0) ){
                error$msg <- 'No experiments defined!'
                return()
            }
            ##cat('L=', sum( Column.Name[ exprs.idx ] %in%  colnames(global.input$table)))
            ## column names specified in exp design file not found in table
            ##if( sum( Column.Name[ exprs.idx ] %in%  colnames(global.input$table)) != length(exprs.idx) ){
            ##    error$msg <- 'Column names in the experimental design file cannot be found in the data table!'
            ##    return()
           ## }
            ## check whether there are at least 2 replicates per group
            num.rep=table(Experiment[exprs.idx])
            ##if(min(num.rep) == 1){
            ##    error$msg <- paste('No replicate measurements defined!')
            ##    return()
            ##}

            ##################################
            ## ANNOTATION: extract empty cells
            ## - corresponding columns will be carried over as
            ##   annotation columns in the result file
            grp.anno <- grp.file[which(nchar(grp.file$Experiment) == 0 ), ]
            grp.anno <- setdiff( grp.anno$Column.Name, input$id.col.value )
            if(length(grp.anno)>0)
                global.input$table.anno <- global.input$table[ , grp.anno]

            ##cat('test')
            ##################################
            ## EXPRESSION
            ## - extract all non-empty cells in the 'Experiment' column
            grp.exprs <- grp.file[exprs.idx, ]

            ## class vector
            grp=grp.exprs$Experiment
            names(grp)=grp.exprs$Column.Name

            ## update input table, keep id and expression columns
            global.input$table <- global.input$table[ , c(input$id.col.value, names(grp))]

            ################################
            ## update number of groups
            global.param$N.grp <- length(unique( na.omit(grp)) )
            ## store group assignment
            global.param$grp <- grp
            ## group colors
            grp.col <- rep(GRPCOLORS[1], length(grp))
            for(i in 2:length(unique(grp))) grp.col[ which(grp == unique(grp)[i]) ] <- GRPCOLORS[i]
            global.param$grp.colors <- grp.col

            ## group colors for figure legend
            idx <- !duplicated(grp)
            grp.col.legend = grp.col[idx]
            names(grp.col.legend) <- grp[idx]
            global.param$grp.colors.legend <- grp.col.legend

            ## all done
            global.param$grp.done = T

            ##
            global.param$id.col.value = input$id.col.value

        })

        ################################################################################
        ##
        ##                once the 'run test' button was pressed...
        ##
        ## 1) log-transform (optional)
        ## 1) normalization (optional)
        ## 2) reproducibility filter (optional)
        ## 3) test (optional)
        ##
        ################################################################################
        observeEvent(input$run.test, {

            ## reset any error messages
            error$msg <- NULL

            global.input$run.test <- input$run.test
            ##cat('run.test:', input$run.test, '\n')

            ###########################################
            ## - store which test has been used
            ## - needed to supress volcanos for mod F test
            global.param$which.test <- input$which.test
            global.param$repro.filt <- input$repro.filt
            global.param$norm.data <- input$norm.data
            global.param$log.transform <- input$log.transform


            #####################################################################
            ## if the 'Run test' - button has been pressed for the first time,
            ## store a copy of the original input matrix (unnormalized, unfiltered)
            ##if (global.input$run.test == 1){
            if(!(global.param$analysis.run)){
                global.input$table.org <- global.input$table
                tab <- data.frame(global.input$table)
            }
            ##if(global.input$run.test > 1 ){
            if(global.param$analysis.run){
                tab <- data.frame(global.input$table.org)
            }
            ##View(tab)
            ## id column
            id.col = global.param$id.col.value
            ## all group labels
            groups=global.param$grp

            ###############################################
            ## initialize values for normalized and filtered matrix
            global.results$table.norm=NULL
            global.results$table.repro.filt=NULL
            global.results$pca=NULL
            global.results$table.log=NULL
            global.results$repro.filt=NULL

            ###############################################
            ## determine which test should be performed
            test = global.param$which.test
            norm.data = global.param$norm.data
            repro.filt = global.param$repro.filt
            log.trans = global.param$log.transform

            ###############################################
            ## specify which comparisons should be performed
            if(test %in% c('One-sample mod T', 'mod F', 'none')){
                ## each group separetely
                groups.comp <- global.param$grp
                global.param$grp.comp <- groups.comp
            }
            if(test == 'Two-sample mod T'){
                ## all pairwise combinations
                groups.unique <- unique(global.param$grp)

                groups.comp <- c()
                count=1
                for(i in 1:(length(groups.unique)-1))
                    for(j in (i+1):length(groups.unique)){
                        groups.comp[count] <- paste(groups.unique[i], groups.unique[j], sep='.vs.')
                        count <- count+1
                    }
                global.param$grp.comp <- groups.comp
            }

            #############################################
            ## log transformation
            #############################################
            if(log.trans != 'none'){
                ids.tmp <- tab[, id.col]
                dat.tmp <- tab[, -which(colnames(tab) == id.col)]
                dat.tmp <- data.matrix(dat.tmp)

                dat.tmp[dat.tmp == 0] <- NA

                if(log.trans == 'log2'){
                    dat.tmp <- log(dat.tmp, 2)
                }
                if(log.trans == 'log10'){
                    dat.tmp <- log(dat.tmp, 10)
                }
                ## putting a dataframe around here turns out to be ESSENTIAL!! DON'T USE CBIND HERE!
                tab <- data.frame( ids.tmp, dat.tmp)
                colnames(tab)[1] <- id.col
                ## store
                global.results$table.log <- tab
            }

            #############################################
            ## normalization
            #############################################
            if(norm.data != 'none'){
                ##tab.org = tab
                withProgress(message='Applying normalization...', {
                    tab <- normalize.data(tab, id.col, norm.data)
                    if(is.null(dim(tab)) | unlist(tab) == 'No_success'){

                        error$msg <- paste('Error in Two-component normalization:<br><br>Could not fit mixture model for data column:<br><br>', tab, '<br><br>Giving up...')

                        ## if not successful skip the rest
                        test='none'
                        repro.filt='no'

                    } else {
                        global.results$table.norm <- tab
                        ##View(tab)
                    }
                })
            }
            ##############################################
            ##
            ## reproducibility filter
            ## - only for one-sample test
            ##
            ##############################################
            if(repro.filt == 'yes'){

                if( test == 'One-sample mod T'){

                    withProgress(message='Applying reproducibility filter',  {
                        repro = my.reproducibility.filter(tab, id.col=id.col, groups, alpha=0.05)
                        tab = repro$table
                        ##View(repro$table)
                    })
                    ## store indices of filtered values in the original table
                    global.results$repro.filt <- repro$values.filtered
                    global.results$table.repro.filt <- tab

                } else {
                    global.param$repro.filt <- 'no'
                }
            }
            ########################################################################################
            ##
            ##                                     TEST
            ##
            ########################################################################################

            ##################################
            ## two sample
            if(test == 'Two-sample mod T'){
                ##View(tab)
                withProgress(message='Two-sample test', value=0, {

                    count=0
                    ## loop over groups
                    for(g in unique(groups.comp)){

                        ## extract current groups
                        ##groups.tmp <- groups[grep(paste( unlist( strsplit(g, '\\.vs\\.')), collapse='|'  ) , groups) ]
                        groups.tmp <- groups[ c(grep( paste('^',unlist( strsplit(g, '\\.vs\\.'))[1],'$', sep='') , groups), grep(paste('^',unlist( strsplit(g, '\\.vs\\.'))[2], '$', sep='') , groups)) ]

                        ## extract table of current group
                        tab.group <- cbind(tab[, id.col], tab[, names(groups.tmp)])
                        colnames(tab.group)[1] <- id.col

                        ##cat(paste(names(groups.tmp), collapse=' '))
                        ##cat('\n')
                        ##cat(paste(groups.tmp, collapse=' '))
                        ##cat('\n')
                        ##cat(g)

                        #############################
                        ## the actual test
                        #############################
                        res.tmp <-  modT.test.2class( tab.group, groups=groups.tmp, id.col=id.col, label=g )$output
                        ##View(res.tmp)

                        if(count == 0){
                            res.comb <- res.tmp
                        } else {
                            ##res.comb <- merge(res.comb, res.tmp, sort=F)
                            ##res.comb <- merge(res.comb, res.tmp, by='id')

                            ## make sure the order is correct
                            if(nrow(res.tmp ) != nrow(res.comb)) stop( "number of rows don't match!\n" )
                            res.tmp <- res.tmp[rownames(res.comb), ]
                            ##res.comb <- cbind(res.comb, res.tmp)
                            res.comb <- data.frame(res.comb, res.tmp, stringsAsFactors=F)
                        }
                        ##################################################
                        ## progress bar
                        incProgress(count/length(unique(groups.comp)), detail=g)
                        count=count + 1

                    }

                ##################################
                ## reorder table
                res.id <- res.comb$id ## id column
                res.exprs <- res.comb[, names(groups)] ## expression values
                res.test <- res.comb[, grep('^logFC|^AveExpr|^t\\.|^P\\.Value|^adj.P.Val|^Log\\.P\\.Value', colnames(res.comb))] ## test results
                res.test <- res.test[, order(colnames(res.test))]
                ##View(res.id)
                ##View(res.exprs)
                ##View(res.test)
                ## assemble new table
                res.comb <- data.frame(id=res.id, res.test, res.exprs)
                ##View(res.comb)
                ##View(tab)
                ##res.comb <- res.comb[tab[, id.col], ]
                res.comb <- res.comb[rownames(tab),]
                ##View(res.comb)
                ##View(tab)
                global.results$data$output <- res.comb


                })
            }
            ##################################
            ## one sample
            if(test == 'One-sample mod T'){
               ## cat('test...')
                withProgress(message='One-sample test', value=0, {

                    count=0
                    ## loop over groups
                    for(g in unique(groups.comp)){

                        setProgress(detail=g)

                        ## extract table of current group
                        tab.group <- cbind(tab[, id.col], tab[, names(groups)[which(groups == g)]])
                        colnames(tab.group)[1] <- id.col

                        ##View(tab.group)

                        res.tmp <- modT.test( tab.group, id.col=id.col, plot=F, nastrings=NASTRINGS, label=g, na.rm=FALSE)$output
                        ##View(res.tmp)
                        if(count == 0){
                            res.comb <- res.tmp
                        } else {
                            if(nrow(res.tmp ) != nrow(res.comb)) stop( "number of rows don't match!\n" )
                            res.tmp <- res.tmp[rownames(res.comb), ]
                            res.comb <- cbind(res.comb, res.tmp)
                            ##res.comb <- merge(res.comb, res.tmp, sort=F)
                            ##res.comb <- merge(res.comb, res.tmp, by='id')
                        }

                        #############################################
                        ## progress bar
                        ##incProgress(1/length(unique(groups.comp)))
                        incProgress(count/length(unique(groups.comp)))
                        count=count + 1
                    }
                    ## add ids as rownames
                    ##rownames(res.comb) <- res.comb$id
                    ##colnames(res.comb) <- sub('^X', '', colnames(res.comb))
                })

                ##################################
                ## reorder columns of the table
                res.id <- res.comb$id ## id column
                res.exprs <- res.comb[, names(groups)] ## expression values
                ##View(res.exprs)
                res.test <- res.comb[, grep('^logFC|^AveExpr|^t\\.|^P\\.Value|^adj.P.Val|^Log\\.P\\.Value', colnames(res.comb))] ## test results
                ##View(res.test)
                res.test <- res.test[, order(colnames(res.test))]
                ## assemble new table
                res.comb <- data.frame(id=res.id, res.test, res.exprs)
                ##res.comb <- res.comb[tab[, id.col], ]
                res.comb <- res.comb[rownames(tab),]
                ###########################################
                ## store the results
                global.results$data$output <- res.comb
            }

            ##################################
            ## moderated F test
            if(test == 'mod F'){
                cat('test F...')
                withProgress(message='moderated F-test', value=0, {

                        res.comb <- modF.test( tab, id.col=id.col, class.vector=groups, nastrings=NASTRINGS, na.rm=FALSE)$output
                        colnames(res.comb) <- sub('^X', '', colnames(res.comb))
                })
                ##################################
                ## reorder table
                res.id <- res.comb$id ## id column
                ##res.exprs <- res.comb[, names(groups)] ## expression values
                res.exprs <- tab[, names(groups)]
                res.test <- res.comb[, grep('^logFC|^AveExpr|^F$|^P\\.Value$|^adj.P.Val$|^Log\\.P\\.Value', colnames(res.comb))] ## test results
                res.test <- res.test[, order(colnames(res.test))]

                ## assemble new table
                res.comb <- data.frame(id=res.id, res.test, res.exprs)
                ##res.comb <- res.comb[tab[, id.col], ]
                res.comb <- res.comb[rownames(tab),]
                ###########################################
                ## store the results
                 global.results$data$output <- res.comb
            }

            ###################################################################
            ##
            ##                       no test
            ##
            ###################################################################
            if(test == 'none'){
                ###########################################
                ## store data matrix as test results
                ## - values are log
                res.comb <- tab
                ###########################################
                ## store the results
                global.results$data$output <- res.comb

            }
            ###################################################################
            ##
            ##              export result table to Excel
            ##
            ##
            ####################################################################
            ##tmp <- sort(global.param$grp)

            ## append annotation columns
           ## if(!is.null(global.input$table.anno))
           ##     res.comb <- cbind(res.comb, Annotation.starts.here=rep('', nrow(res.comb)), global.input$table.anno)
            ##expDesign <- data.frame(Column=names(tmp), Experiment=tmp)

            ##withProgress(message='Generating result table...', {

                ## generate_filename
           ##     fn.tmp <- sub(' ','_', paste(global.param$session.dir, '/', 'results_', sub(' ', '_',global.param$which.test),  ifelse(global.param$log.transform != 'none', paste('_', global.param$log.transform, sep=''), '_'), ifelse(global.param$norm.data != 'none', paste('_', global.param$norm.data, sep=''), '_'), ifelse(input$repro.filt=='yes', paste('_reprofilt', sep=''), '_'), sub(' .*', '', Sys.time()),".xlsx", sep=''))
           ##     global.param$ExcelFileName <- fn.tmp
                ## Excel
                ##WriteXLS(c('res.comb', 'expDesign'), ExcelFileName=paste( TMPDIR, global.param$session, '.xlsx',sep=''), FreezeRow=1, FreezeCol=1, SheetNames=c('modT', 'class vector'), row.names=F, BoldHeaderRow=T, AutoFilter=T)
          ##      WriteXLS(c('res.comb', 'expDesign'), ExcelFileName=fn.tmp, FreezeRow=1, FreezeCol=1, SheetNames=c('modT', 'class vector'), row.names=F, BoldHeaderRow=T, AutoFilter=T)
            ##})


            #######################################
            ## set some flags
            global.param$analysis.run <- T
            global.results$export.results <- F

            ###################################################################
            ##            insert the panels for the volcanos
            ###################################################################
            if(!(global.param$which.test %in% c('mod F', 'none'))){
                ins.volc()
            }

            ##View(res.comb)
        })

        #######################################################################################################
        ##
        ##
        ##                   filter the test results accross multiple groups
        ##
        ##
        ########################################################################################################
        filter.res  <-  reactive({

            cat('\n-- filter.res --\n')
            cat('filter.type: ', global.param$filter.type, '\nfilter.value:', global.param$filter.value, '\n')

            groups.comp=unique(global.param$grp.comp)

            ## test results
            res <- data.frame(global.results$data$output)

            ##View(res)
            ##if(is.null(input$filter.type))
            global.param$filter.type=input$filter.type



            #################################
            ## top N
            if(global.param$filter.type=='top.n'){

                ######################################
                ## multiple comparisons
                if(length(groups.comp) > 1){

                    ###########################################
                    ## one/two sample tests
                    if(global.param$which.test != 'mod F'){

                        ## order according to minimal p-value
                        res <- res[ order( unlist(apply( res[, grep('^P.Value', colnames(res) )], 1, min))  ), ]
                        res <- res[ 1:input$filter.value.top.n, ]

                        ## order according to FC
                        res <- res[order( unlist(apply( res[, grep('^logFC', colnames(res) )], 1, min))  ), ]

                        ## now separate for each group comparison
                        res.groups <- lapply(groups.comp, function(g){
                            res.filt=res[ which(!is.na(paste('P.Value.', g, sep='') )), ]
                            res.filt=res.filt[ order( res.filt[, paste('P.Value.', g, sep='') ], decreasing=F) , ]
                            res.filt[1:input$filter.value.top.n, ]
                        })
                        names(res.groups) <- groups.comp

                    #########################################
                    ## F test
                    } else {

                        ## order according to
                        res <- res[order(res[, 'P.Value'], decreasing=F)[1:input$filter.value.top.n], ]

                        res.groups <- list(res)
                        names(res.groups) <- paste(groups.comp, collapse='|')
                    }

                    #################################################
                    ## one comparison only
                } else {
                     res <- res[order(res[, paste('P.Value.', groups.comp, sep='')]) , ]
                     res <- res[1:input$filter.value.top.n, ]
                     res <- res[order(res[, paste('logFC.', groups.comp, sep='')]) , ]

                     res.groups <- list(res)
                     names(res.groups) <- groups.comp
                }
                global.param$filter.value <- input$filter.value.top.n
            }
            #################################
            ## nominal p-value
            if(global.param$filter.type=='nom.p'){

                ###############################################
                ## multiple group comparisons
                if(length(groups.comp) > 1){

                    ###########################################
                    ## one/two sample tests
                    if(global.param$which.test != 'mod F'){

                        res <- res[ which( unlist(apply( res[, grep('^P.Value', colnames(res) )], 1, function(x) sum(x < input$filter.value.nom.p))) > 0), ]
                        res <- res[order( unlist(apply( res[, grep('^logFC', colnames(res) )], 1, min))  ), ]
                        ## now separate for each group comparison
                        res.groups <- lapply(groups.comp, function(g){
                            res[ which( res[, paste('P.Value.', g, sep='')] < input$filter.value.nom.p) , ]
                        })
                        names(res.groups) <- groups.comp
                    #########################################
                    ## F test
                    } else {
                        res <- res[which( res[, 'P.Value'] < input$filter.value.nom.p), ]

                        res.groups <- list(res)
                        names(res.groups) <- paste(groups.comp, collapse='|')
                    }
                ##############################################
                ## one group comparison
                } else {
                    res <- res[which(res[, paste('P.Value.', groups.comp, sep="")] < input$filter.value.nom.p), ]
                    res <-  res[order(res[, paste('logFC.', groups.comp, sep="")]), ]
                    res.groups <- list(res)
                    names(res.groups) <- groups.comp
                }
                global.param$filter.value <- input$filter.value.nom.p
            }

            #################################
            ## adjusted p-value
            if(global.param$filter.type=='adj.p'){

                ############################################################
                ## multiple group comparisons
                if(length(groups.comp) > 1){

                    ###########################################
                    ## one/two sample tests
                    if(global.param$which.test != 'mod F'){

                        res <- res[ which( unlist(apply( res[, grep('^adj.P.Val', colnames(res) )], 1, function(x) sum(as.numeric(x) < input$filter.value.adj.p ))) > 0), ]
                        res <- res[order( unlist(apply( res[, grep('^logFC', colnames(res) )], 1, min))  ), ]
                        ## now separate for each group comparison
                        res.groups <- lapply(groups.comp, function(g){
                            res[ which( res[, paste('adj.P.Val.', g, sep='')] < input$filter.value.adj.p) , ]
                        })
                        names(res.groups) <- groups.comp
                    ###########################################
                    ## F-test
                    } else {
                        res <- res[which( res[, 'adj.P.Val'] < input$filter.value.adj.p), ]

                        res.groups <- list(res)
                        names(res.groups) <- paste(groups.comp, collapse='|')
                    }
                ##############################################################
                ## one comparison
                } else {
                    res <- res[which(res[, paste('adj.P.Val.', groups.comp,sep='')] < input$filter.value.adj.p), ]
                    res <-  res[order(res[, paste('logFC.', groups.comp, sep="")]), ]
                    res.groups <- list(res)
                    names(res.groups) <- groups.comp
                }

                global.param$filter.value <- input$filter.value.adj.p
            }

            ###################################
            ## global FDR

            #################################
            ## no filter
            if(global.param$filter.type=='none'){
                global.param$filter.value <- 'none'
                res.groups <- lapply(groups.comp, function(g) res)
                names(res.groups) <- groups.comp
            }

            ###################################################
            ## global filter accross all experiments
            global.results$filtered <- res
            ##global.param$filter.type <- input$filter.type
            global.results$filtered.groups <- res.groups

        })

        ###################################################################################################
        ##
        ##                                     output
        ##
        ###################################################################################################

        #############################################################
        ##
        ##                download zip file
        ## - append timestamp to zip-file
        ##
        #############################################################
        output$download.results <- downloadHandler(
            ##filename = function(){paste('results_', gsub('\\:', '',gsub(' ','-',gsub('-','',Sys.time()))), '.zip', sep='') },
	    filename = function(){paste('results', global.param$zip.name, sep='_')},
            content = function(file){
	    	   ## cat('\n\n', paste(global.param$session.dir, global.param$zip.name, '\n\n',sep=''))
                file.copy( paste(global.param$session.dir, global.param$zip.name, sep='/'), file)
            }, contentType = "application/zip"
        )

        ##################################################
        ##
        ##           export the result table
        ##
        ##################################################
        ## Excel
       ## output$downloadExcel <- downloadHandler(
       ##     filename = function(){ paste(sub(' ', '_',global.param$which.test),  ifelse(global.param$log.transform != 'none', paste('_', global.param$log.transform, sep=''), '_'), ifelse(global.param$norm.data != 'none', paste('_', global.param$norm.data, sep=''), '_'), ifelse(input$repro.filt=='yes', paste('_reprofilt', sep=''), '_'), sub(' .*', '', Sys.time()),".xlsx", sep='') },
       ##     content = function(file){
       ##         ##file.rename(paste( TMPDIR, global.param$session, '.xlsx', sep=''), file)
       ##         file.rename(global.param$ExcelFileName, file)
       ##     }
       ## )


        ## tab delimited
       ## output$downloadTxt <- downloadHandler(
       ##     filename = function(){ paste("results_", sub(' ', '_',global.param$which.test), '_', sub(' .*', '', Sys.time()), '_', input$norm.data, ifelse(input$repro.filt=='yes', paste('_reprofilt',sep=''), ''),".txt", sep='') },
       ##     content = function(file){
       ##         file.rename(paste( TMPDIR, global.param$session, '.txt', sep=''), file)
       ##     }
       ## )

        #########################################
        ## download experimental design template
        output$exportTemplate <- downloadHandler(
            filename = function(){ 'experimentalDesign.txt' },
            content = function(file){
                tab <- global.input$table
                exp.design <- cbind(colnames(tab), rep('', ncol(tab)))
                colnames(exp.design) <- c('Column.Name', 'Experiment')
                write.table(  exp.design, file, sep='\t', quote=F, na='', row.names=F  )
            }
        )

        #####################################################################################
        ##
        ##                    summary dataset
        ##
        #####################################################################################
        output$summary.data <- renderTable({

            if(is.null(global.results$data)) return()
            if(!is.null(error$msg)) return()

            tab <- data.frame(global.input$table.org)
            ##View(tab)
            ##cat(dim(tab), '\n')
            grp <- global.param$grp
            N.grp <- global.param$N.grp

            ##cat(nrow(tab), ' - ', length(grp), ' - ', N.grp)

            sum.tab <- t(data.frame(
                N.rows=nrow(tab),
                N.columns=length(grp),
                N.groups=N.grp
            ))
            ##View(sum.tab)
            colnames(sum.tab) <- 'Number'
            rownames(sum.tab) <- c('Rows', 'Expression columns', 'Groups')

            sum.tab
        })
        #####################################################################################
        ##
        ##                summary workflow
        ##
        #####################################################################################
        output$summary.workflow <- renderTable({

            if(is.null(global.results$data)) return()
            if(!is.null(error$msg)) return()

            filter.res()
            ##cat(length(input$log.trans), '\n')

            ##cat(length(input$norm.data), '\n')
            wf.tab <- t(data.frame( global.param$log.transform, global.param$norm.data, global.param$repro.filt,  global.param$which.test,
                                   paste( global.param$filter.type, ' < ', global.param$filter.value) ))
            rownames(wf.tab) <- c('Log scale', 'Normalization', 'Reproduc.Filter', 'Test', 'Filter')
            colnames(wf.tab) <- 'Value'

            ## special case: no filter
            if(global.param$filter.type == 'none')
                wf.tab['Filter', 'Value'] <- 'none'
            ## special case: top N
            if(global.param$filter.type == 'top.n')
                wf.tab['Filter', 'Value'] <- paste('top', global.param$filter.value)


            wf.tab

        })
        #####################################################################################
        ##
        ##                summary test results
        ##
        #####################################################################################
        output$summary.test <- renderTable({

            if(is.null(global.results$data)) return()
            if(!is.null(error$msg)) return()

            ## extract results
            filter.res()

            res = global.results$filtered

            ## tested groups
            grp.comp=unique(global.param$grp.comp)

            ## extract filter type
            filter.type=global.param$filter.type
            filter.value=global.param$filter.value

            ######################################
            ## one/two sample mod T
            if(global.param$which.test != 'mod F'){

                if(filter.type == 'adj.p')
                    test.tab=unlist(lapply(paste('adj.P.Val', grp.comp, sep='.'), function(x) sum(res[, x] < filter.value) ))
                if(filter.type == 'nom.p')
                    test.tab=unlist(lapply(paste('P.Value', grp.comp, sep='.'), function(x) sum(res[, x] < filter.value) ))
                if(filter.type == 'top.n')
                    return(NULL)

                if(filter.type == 'none')
                    return(NULL)

                test.tab=data.frame(test.tab)
                colnames(test.tab) <- 'Number significant'
                rownames(test.tab) <- make.names(grp.comp)
                return(test.tab)

            #######################################
            ## moderated F
            } else {
                if(filter.type == 'adj.p')
                    test.tab=data.frame(  sum(res[, 'adj.P.Val'] < filter.value) )
                if(filter.type == 'nom.p')
                    test.tab=data.frame(  sum(res[, 'P.Value'] < filter.value) )
                if(filter.type == 'top.n')
                    return(NULL)
                if(filter.type == 'none')
                    return(NULL)

                test.tab <- data.frame(test.tab)
                colnames(test.tab) <- 'Number significant'
                rownames(test.tab) <- paste(unique(global.param$grp), collapse=' vs. ')
                return(test.tab)
            }

        })
        #################################################################
        ##
        ##          missing data distribution
        ##
        #################################################################
        output$summary.missing.data.row <- renderPlotly({
            if(is.null(global.results$data)) return()
            ##if(!is.null(error$msg)) return()

            tab <- data.frame(global.input$table.org)
            grp <- global.param$grp
            N.grp <- global.param$N.grp
            grp.colors.legend <- global.param$grp.colors.legend

            ## extract expression values
            dat <- tab[, -which(colnames(tab) == global.param$id.col.value)]
            dat <- data.matrix(dat)

            ##na.col.idx <- apply(dat, 2, function(x) sum(is.na(x)))

            ##p <- plot_ly( x=names(na.col.idx), y=na.col.idx, type='bar' )
            ##p <- layout(p, title='Number of missing values per data column', scene=list(xaxis='Data column', yaxis='# missing values'))


            na.row.idx <- table(apply(dat, 1, function(x) sum(is.na(x))))
            p <- plot_ly( x=names(na.row.idx), y=na.row.idx, type='bar' )
            p <- layout(p, title='Number of missing values per data row', xaxis=list(title=paste('# missing values')), yaxis=list(title=paste('# data rows')))
            ##barplot(na.col.idx)
            p
        })
        #########################################
        ## per column
        output$summary.nonmissing.data <- renderPlotly({
            if(is.null(global.results$data)) return()

            tab <- data.frame(global.input$table.org)
            grp <- global.param$grp
            N.grp <- global.param$N.grp
            grp.colors.legend <- global.param$grp.colors.legend
            grp.colors <- global.param$grp.colors

            ## extract expression values
            dat <- tab[, -which(colnames(tab) == global.param$id.col.value)]
            dat <- data.matrix(dat)

            ## order columns
            ord.idx <- order(grp)
            dat <- dat[, ord.idx]
            grp.colors <- grp.colors[ord.idx]
            grp <- grp[ord.idx]
            grp.colors.legend <- grp.colors.legend[order(names(grp.colors.legend))]
            names(grp.colors) <- colnames(dat)

            ## number of non-missing values per row
            na.col.idx <- apply(dat, 2, function(x) sum(!is.na(x)))

            ## plot
            p <- plot_ly( x=names(na.col.idx), y=na.col.idx,  color=grp, colors=grp.colors.legend, type='bar')
            p <- layout(p, title='Number of valid data points per data column', xaxis=list(title=paste('Data columns')), yaxis=list(title=paste('# data points')))

            p
        })


        #####################################################################################
        ##
        ##             display the corresponding part of the table
        ##
        #####################################################################################
        output$tableprev <- renderDataTable({

            if(is.null(global.results$data)) return()
            if(!is.null(error$msg)) return()

            filter.res()

            tab <- global.results$filtered
            colnames(tab) <- sub('^X','',colnames(tab))
            ##rownames(tab) <- tab[, input$id.col.value]

            ## check whether there is annotation stored
            if(!is.null(global.input$table.anno))
                    tab <- cbind(tab, global.input$table.anno[ rownames(tab), ])


            if(nrow(tab) > 0){
                ## add links to uniprot
                up.id <- tab[, 'id']
                ##up.id <- tab[, input$id.col]
                ##up.id <- tab[, global.param$id.col.value]
                up.link <- paste("<a href='http://www.uniprot.org/uniprot/", sub('(_|,|;).*', '', up.id),"' target='_blank'>", up.id, "</a>", sep='')
                tab[, 'id'] <- up.link
                ##tab[, input$id.col] <- up.link
                ##tab[, global.param$id.col.value] <- up.link
            }
            tab

        }, options = list( pageLength = 50), escape=F)


        #####################################################################################
        ##
        ##                             Volcano plot
        ##
        #####################################################################################

        ###################################################################
        ## function to generate the panels for the volcanos
        ## insert the plots into the webpage
        ###################################################################
        ins.volc <- reactive({

            if(global.param$which.test %in% c('mod F', 'none')) return()
            ##if(!is.null(error$msg)) return()

            grp.comp <- unique( global.param$grp.comp )

            for(i in 1:length(grp.comp)){
              local({
                  my_i <- i
                  ##########################
                  ## the actual plots
                  output[[paste("volcano", grp.comp[my_i], sep='.')]] <- renderPlot({
                      plotVolcano( grp.comp[my_i], max.logP=input$max.logP )
                  })

                  ##########################
                  ## download button
                  output[[paste("downloadVolcano", grp.comp[my_i], sep='.')]] <- downloadHandler(
                      filename = paste('volcano_', global.param$filter.type, '_', global.param$filter.value, '.pdf', sep=''),
                      ##filename =  paste( 'volcano_',grp.comp[my_i],'.pdf'),
                      content = function(file){

                          pdf(file, height=11, width=11)

                          for(j in 1:length(grp.comp)){
                              local({
                                  my_j=j
                                  plotVolcano(grp.comp[my_j], max.logP=input$max.logP)
                              })
                          }
                          dev.off()
                      }
                  ) ## end download handler

                  ##################################
                  ## info table
                  output[[paste('info', grp.comp[my_i], sep='.')]] <-  renderTable({
                      if(is.null(global.results$data)) return()
                      res <- as.data.frame( global.results$data$output )
                      text.tmp <- nearPoints(res, input[[paste('plot_hover', grp.comp[my_i], sep='.')]], threshold=10, maxpoints =  1, xvar=paste('logFC', grp.comp[my_i], sep='.'), yvar=paste('Log.P.Value', grp.comp[my_i], sep='.'))
                      text.tmp <- text.tmp[, c('id', paste('logFC', grp.comp[my_i], sep='.'), paste('P.Value',grp.comp[my_i], sep='.'), paste('adj.P.Val', grp.comp[my_i], sep='.'))]
                      rownames(text.tmp) <- NULL
                      if( nrow(text.tmp) == 1 )
                          text.tmp
                      else{
                          text.tmp[1, ] <- rep(' ', ncol(text.tmp))
                          text.tmp
                      }
                  })

                  ##################################
                  ## observe clicks
                  observeEvent(input[[paste('plot_click', grp.comp[my_i], sep='.')]], {
                      res <- as.data.frame( global.results$data$output )
                      ##group.comp <- unique(global.param$grp.comp)

                      text.tmp <- nearPoints(res, input[[paste('plot_click', grp.comp[my_i], sep='.')]], threshold=10, maxpoints =  1, xvar=paste('logFC', grp.comp[my_i], sep='.'), yvar=paste('Log.P.Value', grp.comp[my_i], sep='.'))

                      if(nrow(text.tmp) == 1){
                          ################################################
                          ## first click
                          if(is.null(volc[[ paste('x', grp.comp[my_i], sep='.')]] )){
                              volc[[paste('x', grp.comp[my_i], sep='.')]] = text.tmp[paste('logFC', grp.comp[my_i], sep='.')]
                              volc[[paste('y', grp.comp[my_i], sep='.')]] = text.tmp[paste('Log.P.Value', grp.comp[my_i], sep='.')]
                              volc[[paste('text', grp.comp[my_i], sep='.')]] = text.tmp['id']
                              volc[[paste('xy', grp.comp[my_i], sep='.')]] = paste(text.tmp[paste('logFC', grp.comp[my_i], sep='.')], text.tmp[paste('Log.P.Value', grp.comp[my_i], sep='.')])
                              volc[[paste('P.Value', grp.comp[my_i], sep='.')]] <- text.tmp[paste('P.Value', grp.comp[my_i], sep='.')]
                              volc[[paste('adj.P.Val', grp.comp[my_i], sep='.')]] <- text.tmp[paste('adj.P.Val', grp.comp[my_i], sep='.')]
                          } else {
                              ######################################################
                              ## REMOVE: check if point is present already
                              if( paste(text.tmp[paste('logFC', grp.comp[my_i], sep='.')], text.tmp[paste('Log.P.Value', grp.comp[my_i], sep='.')]) %in% volc[[paste('xy', grp.comp[my_i], sep='.')]]){

                                  ## if so remove from the list
                                  idx = which( volc[[paste('xy', grp.comp[my_i], sep='.')]] == paste(text.tmp[paste('logFC', grp.comp[my_i], sep='.')], text.tmp[paste('Log.P.Value', grp.comp[my_i], sep='.')]))

                                  if(length(volc[[paste('xy', grp.comp[my_i], sep='.')]] > 1)){
                                      volc[[paste('x', grp.comp[my_i], sep='.')]] <- volc[[paste('x', grp.comp[my_i], sep='.')]][-idx]
                                      volc[[paste('y', grp.comp[my_i], sep='.')]] <- volc[[paste('y', grp.comp[my_i], sep='.')]][-idx]
                                      volc[[paste('text', grp.comp[my_i], sep='.')]] <- volc[[paste('text', grp.comp[my_i], sep='.')]][-idx]
                                      volc[[paste('xy', grp.comp[my_i], sep='.')]] <- volc[[paste('xy', grp.comp[my_i], sep='.')]][-idx]
                                      volc[[paste('P.Value', grp.comp[my_i], sep='.')]] <- volc[[paste('P.Value', grp.comp[my_i], sep='.')]][-idx]
                                      volc[[paste('adj.P.Val', grp.comp[my_i], sep='.')]] <- volc[[paste('adj.P.Val', grp.comp[my_i], sep='.')]][-idx]
                                  } else {
                                      volc[[paste('text', grp.comp[my_i], sep='.')]] <- volc[[ paste('y', grp.comp[my_i], sep='.') ]] <- volc[[paste('x', grp.comp[my_i], sep='.')]] <- volc[[paste('xy', grp.comp[my_i], sep='.')]] <- volc[[paste('adj.P.Val', grp.comp[my_i], sep='.')]] <- volc[[paste('P.Value', grp.comp[my_i], sep='.')]]<- NULL
                                                    }
                                  ################################################
                                  ## ADD: if selected point is not present add it to the list
                              } else{
                                  volc[[paste('x', grp.comp[my_i], sep='.')]]=c( volc[[paste('x', grp.comp[my_i], sep='.')]],
                                                                      text.tmp[paste('logFC', grp.comp[my_i], sep='.')])
                                  volc[[paste('y', grp.comp[my_i], sep='.')]]=c(volc[[paste('y', grp.comp[my_i], sep='.')]], text.tmp[paste('Log.P.Value', grp.comp[my_i], sep='.')])
                                  volc[[paste('text', grp.comp[my_i], sep='.')]]=c(volc[[paste('text', grp.comp[my_i], sep='.')]],  text.tmp[ 'id'] )
                                  volc[[paste('xy', grp.comp[my_i], sep='.')]] = c(volc[[paste('xy', grp.comp[my_i], sep='.')]], paste(text.tmp[paste('logFC', grp.comp[my_i], sep='.')], text.tmp[paste('Log.P.Value', grp.comp[my_i], sep='.')]) )

                                  volc[[paste('P.Value', grp.comp[my_i], sep='.')]]=c(volc[[paste('P.Value', grp.comp[my_i], sep='.')]],  text.tmp[paste('P.Value', grp.comp[my_i], sep='.')] )
                                  volc[[paste('adj.P.Val', grp.comp[my_i], sep='.')]]=c(volc[[paste('adj.P.Val', grp.comp[my_i], sep='.')]],  text.tmp[paste('adj.P.Val', grp.comp[my_i], sep='.')] )
                              }
                          }
                      }
                  }) ## end observe clicks

                  ######################################################
                  ## table of selected features
                  output[[paste('volc.tab.selected', grp.comp[my_i], sep='.')]] <- renderTable({

                      if(is.null(volc[[paste('x', grp.comp[my_i], sep='.')]])) return()
                      if(length(volc[[paste('x', grp.comp[my_i], sep='.')]]) == 0) return()
                      tags$h4('Selection:')

                      id.tmp <- volc[[paste('text', grp.comp[my_i], sep='.')]]
                      ## dat.select = data.frame(id=unlist(volc[[paste('text', grp.comp[my_i], sep='.')]]), logFC=unlist(volc[[paste('x', grp.comp[my_i], sep='.')]]), xy=unlist(volc[[paste('xy', grp.comp[my_i], sep='.')]]))
                       dat.select = data.frame(id=unlist(volc[[paste('text', grp.comp[my_i], sep='.')]]), logFC=unlist(volc[[paste('x', grp.comp[my_i], sep='.')]]), P.Value=unlist(volc[[paste('P.Value', grp.comp[my_i], sep='.')]]), adj.P.Value=unlist(volc[[paste('adj.P.Val', grp.comp[my_i], sep='.')]]) )
                      up.id <- dat.select[, 'id']
                      up.link <- paste("<a href='http://www.uniprot.org/uniprot/", sub('(_|,|;).*', '', up.id),"' target='_blank'>", up.id, "</a>", sep='')
                      dat.select[, 'id'] <- up.link

                      dat.select
                  }, sanitize.text.function = function(x) x)

              }) ## end local

            } ## end for loop

        }) ## end 'ins.volc'



        ################################################################
        ## volcano - actual plot
        ##
        ################################################################
        plotVolcano <- function(group, max.logP = 100){

            cat('\n-- plotVolcano --\n')
            if(!is.null(error$msg)) return()

            ## apply filter
            filter.res()

            ## pch for significant points
            sig.pch=18

            ## unfiltered
            res = as.data.frame( global.results$data$output )
            ##rownames(res) <- res[, input$id.col.value]
 ## filtered
            res.filt = as.data.frame(global.results$filtered.groups[[group]])
            ##rownames(res.filt) <- res.filt$id

            if(global.param$which.test != 'mod F'){
                ## extract fc and p
                logPVal <- res[, paste('Log.P.Value.', group, sep='')]
            } else {
                ## extract fc and p
                logPVal <- res[, paste('Log.P.Value',  sep='')]
            }

            logFC <- res[, paste('logFC.', group, sep='')]

            ## index of missing values
            rm.idx <- union( which(is.na(logFC)), which(is.na(logPVal)) )
            if(length(rm.idx) > 0){
                res <- res[-rm.idx, ]
                logFC <- logFC[-rm.idx]
                logPVal <- logPVal[-rm.idx]
            }

            ## which filter?
            filter.str <- paste('filter:', global.param$filter.type, '\ncutoff:', global.param$filter.value)

            ######################################################################
            ## extract significant proteins of current group/test
            ######################################################################
            ## one/two sample
            if( global.param$which.test != 'mod F'){
                if(global.param$filter.type == 'top.n'){
                    PVal <- res[, paste('P.Value.', group, sep='')]
                    sig.idx = order(PVal, decreasing=F)[1:global.param$filter.value]
                }
                if(global.param$filter.type == 'nom.p'){
                    PVal <- res[, paste('P.Value.', group, sep='')]
                    sig.idx = which(PVal <= global.param$filter.value)
                }
                if(global.param$filter.type == 'adj.p'){
                    adjPVal <- res[, paste('adj.P.Val.', group, sep='')]
                    sig.idx = which(adjPVal <= global.param$filter.value)
                }
            ######################################
            ## F-test
            } else {
                if(global.param$filter.type == 'top.n'){
                    PVal <- res[, paste('P.Value', sep='')]
                    sig.idx = order(PVal, decreasing=F)[1:global.param$filter.value]
                }
                if(global.param$filter.type == 'nom.p'){
                    PVal <- res[, paste('P.Value', sep='')]
                    sig.idx = which(PVal <= global.param$filter.value)
                }
                if(global.param$filter.type == 'adj.p'){
                    adjPVal <- res[, paste('adj.P.Val', sep='')]
                    sig.idx = which(adjPVal <= global.param$filter.value)
                }
            }
            if(global.param$filter.type == 'none')
                sig.idx = 1:length(logFC)

            pch.vec=rep(19, nrow(res))
            cex.vec=rep( input[[paste('cex.volcano', group, sep='.')]], nrow(res))

            if(length(sig.idx) > 0){
                pch.vec[sig.idx] <- sig.pch
                cex.vec[sig.idx] <- cex.vec[1]+1


            ###################################
            ## set maximal log p value
            if(!is.null( max.logP))
                logPVal[which(logPVal > max.logP)] <- max.logP
            }
            ##cat('max.logP=',max.logP)
            #############################
            ## color gradient
            ##cat('# NA:',sum(is.na(logPVal)),'\n', sum(is.na(na.omit( logPVal))), '\n')
            col=myColorRamp(c('black', 'grey20', 'darkred', 'red', 'deeppink'), na.omit(logPVal), range=c(0, max.logP))
            ##col='blue'

            ## limits
            xlim = max(abs(logFC), na.rm=T)
            ##xlim <- max( abs(res), na.rm=T)
            xlim = xlim + xlim*.1
            xlim = c(-xlim, xlim)

            ## y-limits
            ylim = ifelse(is.null(max.logP), max(logPVal, na.rm=T), max.logP)
            ylim = c(0, ylim+.2*ylim)

            ####################################################
            ## plot
            par(mar=c(4,5,5,2))
            plot.new()
            plot.window( xlim=xlim, ylim=ylim, cex.axis=1.8, cex.lab=1.8)
            ## title
            mtext(group, side=3, cex=2, line=2)
            ## label axes
            ##mtext(expression(log(FC)), side=1, cex=1.8, line=3)
            if(global.param$which.test == 'Two-sample mod T')
                mtext( paste("log(", sub('.*\\.vs\\.', '', group), "/", sub('\\.vs.*', '', group),")"), side=1, cex=1.8, line=3)
            else
                mtext(expression(log(FC)), side=1, cex=1.8, line=3)

            mtext(expression(-10*log[10](P-value)), side=2, cex=1.8, line=3)
            ## draw axes
            axis(1, cex.axis=1.8)
            axis(2, las=2, cex.axis=1.8)
            ## grid
            if( input[[paste('grid.volcano', group, sep='.')]] )
                grid()
            ## actual plot
            points(logFC, logPVal, col=col, pch=pch.vec, cex=cex.vec)
            ##points(logFC, logPVal, col=col)
            ## add filter
            abline(h=min(logPVal[sig.idx], na.rm=T), col='grey30', lwd=2, lty='dashed')
            text( xlim[2]-(xlim[2]*.05), min(logPVal[sig.idx], na.rm=T), paste(global.param$filter.type, global.param$filter.value, sep='='), pos=3, col='grey30')
            ## number of significant
            legend('top', bty='n', legend=paste(filter.str, '\nsig / tot: ', length(sig.idx),' / ', sum(!is.na(logFC) & !is.na(logPVal)), sep=''), cex=1.5)

            ##############################
            ## indicate directionality for two-sample tests
            if(global.param$which.test == 'Two-sample mod T'){
                legend('topleft', legend=sub('\\.vs.*', '', group), cex=2, text.col='darkblue', bty='n')
                legend('topright', legend=sub('.*\\.vs\\.', '', group), cex=2, text.col='darkblue', bty='n')
            }
            ## legend('topleft', legend=paste('\n', sum()))
            ## add selected points
            if(!is.null( volc[[paste('x', group, sep='.')]] ) & length(volc[[paste('x', group, sep='.')]]) ){
                for(i2 in 1:length(unlist(volc[[paste('x', group, sep='.')]])))
                   text(unlist(volc[[paste('x', group, sep='.')]][i2]), unlist(volc[[paste('y', group, sep='.')]][i2]), unlist(volc[[paste('text', group, sep='.')]][i2]),pos=ifelse(volc[[paste('x', group, sep='.')]][i2] < 0, 2, 4), cex=input[[paste('cex.volcano.lab', group, sep='.')]])
            }
            ##if( input[[paste('grid.volcano', group, sep='.')]] )
            ##    grid()
        }

        #######################################################################################
        ##
        ##                                profile plots
        ##
        #######################################################################################
        output$expr.profile <- renderPlot({
            if(is.null(global.results$data)) return()

            ## dataset
            if(is.null(global.results$table.log))
                tab <- data.frame(global.input$table)
            else
                tab <- data.frame(global.results$table.log)

            ## id column
            id.col.value <- global.param$id.col.value
            ## group vector
            grp <- global.param$grp
            ## group colors
            grp.col <- global.param$grp.colors
            grp.col.leg <- global.param$grp.colors.legend

            withProgress({
                   setProgress(message = 'Processing...', detail= 'Generating profile plots')
                   makeProfileplot(tab, id.col.value, grp, grp.col, grp.col.leg, main='unnormalized')
            })

        })
        ###########################
        ## normalized
        output$expr.profile.norm <- renderPlot({
            if(is.null(global.results$data)) return()

            ## dataset
            tab <- data.frame(global.results$table.norm)

            ## id column
            id.col.value <- global.param$id.col.value
            ## group vector
            grp <- global.param$grp
            ## group colors
            grp.col <- global.param$grp.colors
            grp.col.leg <- global.param$grp.colors.legend

            withProgress({
                   setProgress(message = 'Processing...', detail= 'Generating profile plots')
                   makeProfileplot(tab, id.col.value, grp, grp.col, grp.col.leg, main=paste(global.param$norm.data, 'normalized'))
            })

        })

        #######################################################################################
        ##
        ##                                    boxplots
        ##
        #######################################################################################

        ######################################
        ## without normalization
        output$expr.boxplot <- renderPlot({

            if(is.null(global.results$data)) return()

            ## dataset
            if(is.null(global.results$table.log))
                tab <- data.frame(global.input$table)
            else
                tab <- data.frame(global.results$table.log)

            ## id column
            id.col.value <- global.param$id.col.value
            ## group vector
            grp <- global.param$grp
            ## group colors
            grp.col <- global.param$grp.colors
            grp.col.leg <- global.param$grp.colors.legend
               withProgress({
                   setProgress(message = 'Processing...', detail= 'Generating Boxplots')
                   makeBoxplot(tab, id.col.value, grp, grp.col, grp.col.leg)
               })
        } ##,
        ##width = function(){ width=1000},
        ##height= function(){ height=max( 30*(ncol( global.input$table)+2), 500) } )
        )
        #################################################
        ## with normalization
        output$expr.boxplot.norm <- renderPlot({

            if(is.null(global.results$data)) return()
            if(is.null(global.results$table.norm)) return()
            if(!is.null(error$msg)) return()

            ## dataset
            tab <- data.frame(global.results$table.norm)
            ## id column
            id.col.value <- global.param$id.col.value
            ## group vector
            grp <- global.param$grp
            ## group colors
            grp.col <- global.param$grp.colors
            grp.col.leg <- global.param$grp.colors.legend

            makeBoxplot(tab, id.col.value, grp, grp.col, grp.col.leg, legend=F)
        }##,
        ##width = function(){ width=1000},
        ##height= function(){ height=max( 30*(ncol( global.input$table)+2), 500) } )
        )
        ######################################################################################
        ##
        ##                                   Correlation
        ##
        ######################################################################################
        output$multi.scatter <- renderPlot({
            ##cat('tesssttt')
            if(is.null(global.results$data)) return()
            ##cat('maxval: ', plotparams$ms.max.val,'\n')
            ##plotMultiScatter( define.max=plotparams$ms.max, min.val=plotparams$ms.min.val, max.val=plotparams$ms.max.val )
            plotMultiScatter( define.max=input$ms.max, min.val=input$ms.min.val, max.val=input$ms.max.val )
        },
        width = function(){120*(ncol(data.frame(global.input$table))-1)},
        height= function(){120*(ncol(data.frame(global.input$table))-1)}
        )

        ###############################
        ## actual plot
        plotMultiScatter <- function(define.max, min.val, max.val){

            cat('\n-- plotMultiScatter  --\n')
            ## dataset
            tab <- data.frame(global.input$table)
            ##tab <- data.frame(global.input$table)
            ##View(tab)
            ## id column
            id.col <- global.param$id.col.value
            rownames(tab) <- tab[, id.col]
            ## table
            tab <- tab[, setdiff(colnames(tab), id.col)]
            ## get groups
            grp <-  global.param$grp
            grp <- sort(grp)
            tab <- tab[, names(grp)]

            ## mapping to colors
            ##grp.col <- rep('grey10', length(grp))
            ##grp.col[which(grp == input$label.g2)] <- 'darkblue'

            colnames(tab) <- chopString(colnames(tab), STRLENGTH)

           ###############################
            ## plot
            withProgress({
                setProgress(message = 'Processing...', detail= 'Calculating correlations')
                my.multiscatter(tab, repro.filt=global.results$repro.filt, grp=grp,  grp.col.legend=global.param$grp.colors.legend, define.max=define.max, max.val=max.val, min.val=min.val)
            })
        }
        ################################
        ## download image, Multiscatter
        ##output$downloadMS <- downloadHandler(
        ##    filename =  paste( 'multiscatter.pdf'),
        ##    content = function(file){
        ##        pdf(file, height=100*ncol(global.input$table)*(11/800), width=100*ncol(global.input$table)*(11/800))
        ##        withProgress({
        ##            ##setProgress(message = 'Processing...', detail= 'Calculation correlations')
        ##            plotMultiScatter(define.max=input$ms.max, max.val=input$ms.max.val, min.val=input$ms.min.val)
        ##        })
        ##        dev.off()
        ##    }
        ##)

        #####################################################
        ## correlation matrix
        output$correlation.matrix <- renderPlot({
            if(is.null(global.results$data)) return()
             withProgress({
                 setProgress(message = 'Processing...', detail= 'Generating Heatmap')
                 plotCorrMat(lower=input$cm.lower, upper=input$cm.upper, display_numbers=input$cm.numb)
             })
        }, width=1200, height=1000)

        #####################################################
        ## correlation matrix transposed
       ## output$correlation.matrix.trans <- renderPlot({
       ##     if(is.null(global.results$data)) return()
       ##      withProgress({
       ##          setProgress(message = 'Processing...', detail= 'Generating Heatmap')
       ##          plotCorrMat(lower=input$cm.lower, upper=input$cm.upper, trans=T, display_numbers=input$cm.numb)
       ##      })
       ## }, width=1200, height=1000)




        ###################################################
        ## correlation matrix
        ###################################################
        plotCorrMat <- function(filename=NA, lower=c('pearson', 'spearman', 'kendall', 'pcor'), upper=c('pearson', 'spearman', 'kendall', 'pcor'), trans=F, display_numbers=T){
            cat('\n-- plotCorrMat --\n')

            ## dataset
            tab <- data.frame(global.input$table)
            ## id column
            id.col <- global.param$id.col.value
            ## class vector
            grp <- sort(global.param$grp)
            grp.col.legend <- global.param$grp.colors.legend

            ## table
            tab <- tab[, setdiff(colnames(tab), id.col)]
            tab <- tab[, names(grp)]

            ## transpose
            if(trans)
                tab=t(tab)

            ###########################
            ## calculate correlations
            withProgress({
                setProgress(message = 'Processing...', detail= 'Calculation correlations')
                            cm.upper <- cor(tab, use='pairwise', method=match.arg(upper))
                            cm.lower <- cor(tab, use='pairwise', method=match.arg(lower))
            })
            ###########################
            ## initialize correlation matrix
            cm <- matrix(NA, ncol=ncol(cm.upper),nrow=nrow(cm.upper), dimnames=dimnames(cm.upper))
            cm[ lower.tri(cm, diag=T) ] <- cm.lower[lower.tri(cm.lower, diag=T)]
            cm[ upper.tri(cm, diag=F) ] <- cm.upper[upper.tri(cm.upper, diag=F)]

            ## colors
            color.breaks = seq(-1, 1, length.out=10)
            color.hm=colorRampPalette(c('blue', 'grey80' , 'red'))(length(color.breaks))

            ## gaps between groups
            gaps.column=cumsum(table(grp))
            gaps.row=gaps.column

            ## annotation of rows/columns
            anno=data.frame(Group=grp)
            anno.color=list(Group=grp.col.legend)

            Rowv=F
            Colv=F

            ##setHook("grid.newpage", function() pushViewport(viewport(x=1,y=1,width=0.9, height=0.9, name="vp", just=c("right","top"))), action="prepend")
            setHook("grid.newpage", function() pushViewport(viewport(x=1,y=1,width=0.9, height=0.9, name="vp", just=c("right","top"))))
            if(trans)
                pheatmap(cm, fontsize_row=10, fontsize_col=10,
                     cluster_rows=Rowv, cluster_cols=Colv, border_col=NA, col=color.hm, filename=filename, labels_col=chopString(colnames(cm), STRLENGTH), labels_row=chopString(rownames(cm), STRLENGTH), main='', display_numbers=display_numbers, fontsize_number=100/ncol(cm)+10, breaks=color.breaks)
            else
                pheatmap(cm, fontsize_row=10, fontsize_col=10,
                     cluster_rows=Rowv, cluster_cols=Colv, border_col=NA, col=color.hm, filename=filename, labels_col=chopString(colnames(cm), STRLENGTH), labels_row=chopString(rownames(cm), STRLENGTH), main='', annotation_col=anno, annotation_colors=anno.color,  annotation_row=anno, display_numbers=display_numbers, fontsize_number=100/ncol(cm)+10, breaks=color.breaks, gaps_col=gaps.column, gaps_row=gaps.row)
            setHook("grid.newpage", NULL, "replace")

            ## add corr coeff
            grid.text(paste(match.arg(upper)), y=.995, x=.4, gp=gpar(fontsize=25))
            grid.text(paste(match.arg(lower)), x=-0.01, rot=90, gp=gpar(fontsize=25))
        }

        ##################################################################
        ## download correlation matrix
        ##output$downloadCM <- downloadHandler(
        ##    filename =  paste( 'corrmat_', paste(unique(c(input$cm.lower, input$cm.upper)), collapse='_'), '.pdf', sep=''),
        ##    content = function(file){
        ##        pdf(file, height=1000*(11/800), width=1200*(11/800))
        ##         withProgress({
        ##             setProgress(message = 'Processing...', detail= 'Generating Correlation Matrix')
        ##             plotCorrMat(filename=NA, lower=input$cm.lower, upper=input$cm.upper)
        ##         })
        ##        dev.off()
        ##    }
       ## )

        ####################################################################################
        ##
        ##                                  Heatmap
        ##
        ####################################################################################
        output$HM <- renderPlot({

            if(is.null(global.results$data)) return()
            if(!is.null(error$msg)) return()

            ######################################
            ## extract results
            filter.res()
            res = global.results$filtered

            ######################################
            ## require at least three significant hits
            if(nrow(res) < 3) return()

            #######################################
            ## heatmap title
            hm.title <- paste('filter:', global.param$filter.type, ' / cutoff:', global.param$filter.value, sep='')
            hm.title = paste(hm.title, '\nsig / total: ', nrow(res), ' / ', nrow( global.results$data$output ), sep='')

            #######################################
            ## extract expression values
            res = res[, names(global.param$grp)]

            ######################################
            ## plot
            if(input$hm.max){
                 withProgress({
                     setProgress(message = 'Processing...', detail= 'Generating Heatmap')
                     plotHM(res=res, grp=global.param$grp, grp.col=global.param$grp.colors, grp.col.legend=global.param$grp.colors.legend,  hm.clust=input$hm.clust, hm.title=hm.title, hm.scale=input$hm.scale, cellwidth=ifelse(ncol(res)<40, 40, 20), fontsize_row=input$cexRow, fontsize_col=input$cexCol, max.val=input$hm.max.val, style=global.param$which.test)
                 })
            } else {
                 withProgress({
                     setProgress(message = 'Processing...', detail= 'Generating Heatmap')
                     plotHM(res=res, grp=global.param$grp, grp.col=global.param$grp.colors, grp.col.legend=global.param$grp.colors.legend,  hm.clust=input$hm.clust, hm.title=hm.title, hm.scale=input$hm.scale, cellwidth=ifelse(ncol(res)<40, 40, 20), fontsize_row=input$cexRow, fontsize_col=input$cexCol, style=global.param$which.test)
                 })
            }
        },
        width = function(){ max(  ifelse( length(global.param$grp)<40, 50, 25)*length(global.param$grp), 1000) },
        height= function(){
            filter.res()
            height=min( dynamicHeightHM( nrow(global.results$filtered)), 1500 )
            return(height)}
        )

        #####################################################################
        ##                   download heatmap
        #####################################################################
        output$downloadHM <- downloadHandler(
            filename =  paste( 'heatmap.pdf'),
            content = function(file){

                ######################################
                ## extract results
                filter.res()
                res = global.results$filtered

                ######################################
                ## require at least three significant hits
                if(nrow(res) < 3) return()

                #######################################
                ## heatmap title
                hm.title <- paste('filter:', global.param$filter.type, ' / cutoff:', global.param$filter.value, sep='')
                hm.title = paste(hm.title, '\nsig / total: ', nrow(res), ' / ', nrow( global.results$data$output ), sep='')

                #######################################
                ## extract expression values
                res = res[, names(global.param$grp)]

                if(input$hm.max){
                    withProgress({
                        setProgress(message = 'Processing...', detail= 'Generating Heatmap')
                        plotHM(res=res, grp=global.param$grp, grp.col=global.param$grp.colors, grp.col.legend=global.param$grp.colors.legend,  hm.clust=input$hm.clust, hm.title=hm.title, hm.scale=input$hm.scale, cellwidth=ifelse(ncol(res)<40, 40, 20), fontsize_row=input$cexRow, fontsize_col=input$cexCol, max.val=input$hm.max.val, style=global.param$which.test, filename=file, cellheight=min( dynamicHeightHM( nrow(global.results$filtered)), 1500 )/nrow(global.results$filtered))
                    })
                } else {
                    withProgress({
                        setProgress(message = 'Processing...', detail= 'Generating Heatmap')
                        plotHM(res=res, grp=global.param$grp, grp.col=global.param$grp.colors, grp.col.legend=global.param$grp.colors.legend,  hm.clust=input$hm.clust, hm.title=hm.title, hm.scale=input$hm.scale, cellwidth=ifelse(ncol(res)<40, 40, 20), fontsize_row=input$cexRow, fontsize_col=input$cexCol, style=global.param$which.test, filename=file, cellheight= min( dynamicHeightHM( nrow(global.results$filtered)), 1500 )/nrow(global.results$filtered), max.val=input$hm.max.val)
                    })
                }
            }
        )

        #####################################################################################
        ## histogram of p-values
        #####################################################################################
        output$pval.hist <- renderPlot({

            if(is.null(global.results$data)) return()
            if(!is.null(error$msg)) return()

            groups.comp <- unique(global.param$grp.comp)

            res = global.results$data$output

            ############################################
            ## mod T
            if(global.param$which.test != 'mod F'){
                par(mfrow=c(length(groups.comp),1))
                for(g in groups.comp){

                    pval <- res[, paste('P.Value', g, sep='.')]
                    hist(pval, breaks=50, main=paste('Histogram of P-values (N=', sum(!is.na(pval)), ')',sep=''), xlab='P-value', cex.main=3, cex.axis=2, cex.lab=2, col='darkblue', border=NA)
                    legend('top', legend=g, cex=2)
                }
            ############################################
            ## mod F
            } else {
                pval <- res[, paste('P.Value')]
                hist(pval, breaks=50, main=paste('Histogram of P-values (N=', sum(!is.na(pval)), ')',sep=''), xlab='P-value', cex.main=3, cex.axis=2, cex.lab=2, col='darkblue', border=NA)
                ##legend('top', legend=paste(groups), cex=2)
            }

        },
        width = function(){ width=1000},
        height= function(){ height=500*ifelse( global.param$which.test != 'mod F', length(unique(global.param$grp.comp)), 1 )} )

        ######################################################################################
        ##
        ##                                 PCA
        ##
        ######################################################################################
        output$pca <- renderPlot({
            if(is.null(global.results$data) | is.na(global.param$filter.value)) return()
            if(!is.null(error$msg)) return()

            ##if(is.null(global.results$data)) return()

              withProgress(message = 'PCA...',{
                    pca=plotPCA()
                  })
            ## store results
            global.results$pca <- pca
        })


        #####################################
        ## plot_ly: user defined components
        output$pcaxy.plotly <- renderPlotly({
            if(is.null(global.results$data) | is.na(global.param$filter.value) | is.null(global.results$pca)) return()
            if(!is.null(error$msg)) return()

            pca <- global.results$pca
            pca.x <- as.numeric(sub('PC ','', input$pca.x))
            pca.y <- as.numeric(sub('PC ','', input$pca.y))

            pca.mat = data.frame(
                PC1=pca$x[, pca.x],
                PC2=pca$x[, pca.y]
            )
            rownames(pca.mat) <- rownames(pca$x)

            ##p <- plot_ly( pca.mat, x=PC1, y=PC2, type='scatter', mode='markers', marker=list(size=20, color=global.param$grp.colors), text=chopString(rownames(pca.mat), STRLENGTH) )
            p <- plot_ly( pca.mat, x=PC1, y=PC2, type='scatter', mode='markers', marker=list(size=20, color=global.param$grp.colors), text=rownames(pca.mat) )
            ##p <- layout(p, title=paste('PC', pca.x,' vs. PC', pca.y, sep=''), scene=list(xaxis = list(title = paste('PC', pca.x)),
            ##                                                                             yaxis=list(title= paste('PC', pca.y))) )
            p <- layout(p, title=paste('PC', pca.x,' vs. PC', pca.y, sep=''), xaxis=list(title=paste('PC', pca.x)), yaxis=list(title=paste('PC', pca.y)) )

        })
        ################################################
        ## 3d scatterplot
        output$pcaxyz.plotly <- renderPlotly({
            if(is.null(global.results$data) | is.na(global.param$filter.value) | is.null(global.results$pca)) return()
            if(!is.null(error$msg)) return()

            pca <- global.results$pca
            pca.x <- as.numeric(sub('PC ','', input$pca.x))
            pca.y <- as.numeric(sub('PC ','', input$pca.y))
            pca.z <- as.numeric(sub('PC ','', input$pca.z))

            pca.mat = data.frame(
                PC1=pca$x[, pca.x],
                PC2=pca$x[, pca.y],
                PC3=pca$x[, pca.z]
            )
            rownames(pca.mat) <- rownames(pca$x)

            ##p <- plot_ly( pca.mat, x=PC1, y=PC2, type='scatter', mode='markers', marker=list(size=20, color=global.param$grp.colors), text=chopString(rownames(pca.mat), STRLENGTH) )
            p <- plot_ly( pca.mat, x=PC1, y=PC2, z=PC3, type='scatter3d', mode='markers', marker=list(size=15, color=global.param$grp.colors), text=rownames(pca.mat) )
            ##p <- layout(p, title=paste('PC', pca.x,' vs. PC', pca.y, sep=''), scene=list(xaxis = list(title = paste('PC', pca.x)),
            ##                                                                             yaxis=list(title= paste('PC', pca.y))) )
            p <- layout(p, title=paste('PC', pca.x,' vs. PC', pca.y, 'vs. PC', pca.z, sep=''), scene=list( xaxis=list(title=paste('PC', pca.x)), yaxis=list(title=paste('PC', pca.y)), zaxis=list(title=paste('PC', pca.z))) )

        })

        ###############################################
        ## static PCA plot
        ###############################################
        plotPCA <- function( plot=T){

            filter.res()

            res <- global.results$filtered

            if(nrow(res) < 3) return()

            ## get groups
            grp <- global.param$grp
            ## mapping to colors
            grp.col <- global.param$grp.colors
            grp.col.leg <- global.param$grp.colors.legend

            ## remove missing values
            rm.idx <- apply(res, 1, function(x) sum(is.na(x)) + sum(is.infinite(x)))
            rm.idx <- which(rm.idx > 0)
            if(length(rm.idx)>0) res <- res[-rm.idx, ]
            if(nrow(res) < 3) return()

            ## plot
            pca <- my.prcomp(t(res[, names(grp)]), col=grp.col, plot=plot, rgl=F, main='', cex.points=5, leg.vec=names(grp.col.leg), leg.col=grp.col.leg)

            return(pca)
        }

        #######################################################
        ## download PCA
        ##output$downloadPCA <- downloadHandler(
        ##    filename = paste('pca_', global.param$filter.type, '_', global.param$filter.value, '.pdf', sep=''),
        ##    ##filename =  paste( 'pca.pdf'),
        ##    content = function(file){
        ##        withProgress(message='Exporting PCA...',{
        ##            pdf(file, height=5, width=15)
        ##            pca=plotPCA()
        ##            dev.off()
        ##        })
        ##    }
        ##)



        ################################################################################################
        ## used for debugging purposes
        output$testplot <- renderPlot({

            if(is.null(global.results$data) | is.na(input$filter.value)) return()

            tab <- global.input$table

            grp <- global.param$grp
            grp <- grp[which(grp==grp[1])]


            repro.ids <- global.results$repro.filt[[unique(grp)]]

            ##tab.repro <- tab[ repro.ids, names(grp) ]

            tab <- tab[, names(grp)]


            ba <-  bland.altman.stats(as.numeric( as.character( tab[, 1 ]) ), as.numeric( as.character( tab[,  2 ] )) )

            par(mfrow=c(1,2))
            ba2 <-  bland.altman.plot(as.numeric( as.character( tab[, 1 ]) ), as.numeric( as.character( tab[,  2 ] )) )

            ##View(tab[repro.ids, ])
            ##View( global.results$table.repro.filt[repro.ids, names(grp)] )

            repro.idx2 <- union( which(ba$diffs < ba$lower.limit), which(ba$diffs > ba$upper.limit))

            mydiff <- tab[, 1] - tab[, 2]

            ##cat( tab[1:5,2], '\n', tab[1:5, 1], '\n\n', ba$diffs[1:5], '\n\n')
            ##cat(mydiff[1:5], '\n')
            ##cat('\n\n', colnames(tab)[1:2],'\n')


            repro.idx3 <- which(mydiff < ba$lower.limit | mydiff > ba$upper.limit)

            ##cat(repro.idx2)
            plot(  tab[,1], tab[, 2] )
            ##points( tab[repro.ids, 1], tab[repro.ids, 2], col='red' )
            points( tab[repro.idx2, 1], tab[repro.idx2, 2], col='blue' )
            points( tab[repro.idx3, 1], tab[repro.idx3, 2], col='green' )



        })

})


###########################################################
