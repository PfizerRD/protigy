################################################################################################################
## Filename: server.r
## Created: October 09, 2015
## Author(s): Karsten Krug
##
## Purpose: Shiny-app to perform differential expression analysis, primarily on proteomics data, to perform
##          simple data QC, to interactively browse through the results and to download high-quality result
##          figures.
##
## This file defines the server logical of the app. It also takes care of most of the user interface.
##
################################################################################################################
library(shiny)

############################################
## set maximum file size for upload
############################################
options(shiny.maxRequestSize = MAXSIZEMB*1024^2)


###########################################################################################################
##                         Define server logic
###########################################################################################################
shinyServer(

    function(input, output, session) {

        #####################################
        ## reactive variables to store
        ## data accross a session
        #####################################

        ## error messages
        error <- reactiveValues()

        ## test results
        global.results <-  reactiveValues(
            data=NULL,
            table.norm=NULL
        )
        ## input data
        global.input <- reactiveValues()
        ## parameters
        global.param <-  reactiveValues(
            grp=NULL,           ## the actual group assignment
            N.grp=NULL,         ## number of defined groups
            grp.colors=NULL,    ## group color assignment
            grp.colors.legend=NULL, ## group colors, names are group names
            grp.done=F          ## group assignment finished?
        )
        ## coordinates in volcano plot
        volc <- reactiveValues()

        ################################################################################
        ##
        ##                                instructions
        ##
        ################################################################################

        #############################
        ## getting started
        output$help.start <- renderText({

            if( !is.null(error$msg) ) return()

            if(!is.null(input$file)) return()
            if(!is.null( global.input$file)) return()

            HTML( paste('<p><h3>Hello Proteomics Broadies!</h3><br><font size=\"4\">Welcome to <b>modT</b>, the Shiny-app that allows you to perform <b>one-sample</b> and <b>two-sample moderated T-tests</b> and to interactively explore the results. You can upload ratio reports generated by <b>Spectrum Mill</b> or any other kind of text file containing expression data and optional annotation columns.</font></p>
<br><p><font size=\"4\">Please note that the expression values in your data matrix should be <b>log-transformed</b>, especially in case of ratio data!</p><br><p>Now go on upload a file and enjoy your analysis.</p></font>', sep='') )
        })

        ##############################
        ## help upload
        output$help.id.column <- renderText({

            if( !is.null(error$msg) ) return()

            if(is.null(input$id.col)) return()
            if(input$id.col > 0 && !is.null(input$id.col.value)) return()

            HTML( paste('<br><br><p><font size=\"4\">Here you can download a template of an experimental design file. You can open this file in Excel and define the groups you want to compare. Replicate measurements have to be grouped under a single name in the \'Experiment\'-column. Please avoid any special character when defining these names!</font></p>') )
        })

        ##############################
        ## help experimental design
        output$help.exp.design <- renderText({

            if( !is.null(error$msg) ) return()

            if(is.null(input$id.col)) return()
            if(input$id.col ==0) return()
            if(global.param$grp.done == T) return()

            HTML( paste('<br><br><p><font size=\"4\">Please upload the experimental design file that you have created using the upload button on the left.</p>') )

        })

        ################################
        ## help test
        output$help.test <- renderText({
            if( !is.null(error$msg) ) return()

            if(global.param$grp.done == F) return()
            if(!is.null(input$run.test))
                if(input$run.test > 0) return()

            HTML( paste('<font size=\"4\"><p><h3>Reproducibility filter</h3>This option is only considered in a <b>one-sample test</b> and will be ignored otherwise. For duplicate measurements a Bland-Altman Filter of 99.9% (+/-3.29 sigma) will be applied. For more than two replicate measurements per group a generalized reproducibility filter is applied which is based on a linear mixed effects model to model the within-group variance and between-group variance (See \'MethComp book (pp 58-61). <i>Comparing Clinical Measurement Methods</i> by Bendix Carstensen\' for more details).</p><p>You can inspect the results of the filtering step in the multiscatter plot under the \'QC\'-tab. Data points removed prior to testing will be depicted in red.
<br><br><h3>Data normalization</h3>You can apply different normalization methods to the data prior to testing. The methods are applied for each column separately, except for \'Quantile\'-normalization which takes the entire matrix into account.</p>
<p>
<ul>
<li><b>Median</b>: Substract the sample median from each value.</li>
<li><b>Median-MAD</b>: Substract the sample median and devide by sample MAD.</li>
<li><b>2-component</b>: Use a mixture-model approach to separate non-changing from changing features and divide both populations by the median of the non-changing features.</li>
<li><b>Quantile</b>: Transform the data such that the quantiles of all sample distributions are the equal.</li>
<li><b>none</b>: The data will be taken as is. Should be used if the data has been already normalized.</li>
</ul>
<br>
<h3>Select test</h3>You can choose between a one-sample and two-sample moderate T-test. If you select the one-sample test each group will be tested separately whether the group mean is significantly  different from zero. In case of a two-sample test each possible pairwise comparison will be performed and tested whether the group means are significantly different from each other. If you defined more than two groups in the experimental design file all pairwise comparisons will be tested.<br><br>
<br></font></p>' ) )
        })

        ################################
        ## help results
        output$help.results <- renderText({

            if( !is.null(error$msg) ) return()

            if(global.param$grp.done == F) return()
            if(!is.null(input$run.test))
                if(input$run.test == 0) return()

            HTML( paste('<p><font size=\"4\">This page allows you to interactively explore the results of you analyis. On the left you can choose between different filters, the results will be updated immediately. The filter that you specify applies to all tabs (\'Heatmap\', \'Volcanos\', ...), except the \'QC\' which shows the entire dataset. You can change the appearance of the heatmap by modifying the parameters below, you can select points shown in the Volcano plots and browse through the result table.</font></p><br>') )
        })

        #################################
        ## F5 hint
        output$F5hint <- renderText({

            HTML('<p align=\"center\"><font size=\"5\"><mark>To analyze another data set or to start over hit the F5 button.</mark></font></p>' )

        })

        #####################################
        ## Error messages
        output$error <- renderText({
            if( is.null(error$msg) ) return()
            HTML(paste('<p align=\"center\"><font size=\"5\" color=\"red\">', error$msg,'</font></p>'))
        })

        ################################################################################
        ##
        ##                                navigation bar
        ##
        ################################################################################
        output$navbar <- renderUI({

            if(is.null(input$file) && is.null( global.input$file)) return()
            if(is.null(input$id.col)) return()
            if( !is.null(input$id.col))
                if( input$id.col == 0 ) return()
            if(is.null(global.results$data)) return()

            ###########################################################################################
            ## determine the number of group comparisons, e.g. for the number of volcano plots to draw
            groups.comp <- unique(global.param$grp.comp)


            ############################################
            ##
            ##   tabs for the volcano plots
            ##
            ############################################
            volc.tabs <- list()
            volc.tabs[[1]] <- 'Volcanos'
            for(i in 1:length(unique(groups.comp))){
                volc.tabs[[i+1]]=tabPanel(paste0( groups.comp[i] ),

                                          fluidPage(
                                              fluidRow(
                                                  column(1, numericInput( paste("cex.volcano",groups.comp[i],sep='.'), "Point size", value=2, min=1, step=1)),
                                                  ##column(1, numericInput( paste("opac.volcano",groups.comp[i],sep='.'), "Opacity %", value=50, min=0, max=100, step=10)),
                                                  column(1, numericInput( paste("cex.volcano.lab",groups.comp[i],sep='.'), "Label size", value=1, min=.1, step=.1)),
                                                  column(1, selectInput( paste("grid.volcano",groups.comp[i],sep='.'), "Grid", c(T, F), selected=T)),
                                                  column(2, numericInput("max.logP", "Max. Log10(P-value)", value=100, min=20, max=100, step=10) ),
                                                  column(5),
                                                  column(1, downloadButton(paste('downloadVolcano', groups.comp[i],sep='.'), 'Download (pdf)'))
                                              ),
                                              tags$br(),
                                              tags$hr(),
                                              tags$br(),
                                              fluidRow(
                                                  column(12, align='center', tableOutput(paste('info',groups.comp[i], sep='.')))
                                              ),
                                              fluidRow(
                                                  column(9, align='center',
                                                         plotOutput( paste("volcano",groups.comp[i], sep='.'), width=800, height=800, click=paste('plot_click', groups.comp[i], sep='.'), hover=paste('plot_hover', groups.comp[i], sep='.'))),
                                                  column(3, tableOutput(paste('volc.tab.selected', groups.comp[i], sep='.')))
                                              )
                                          )
                                        ) ## end tabPanel
            } ## end for i


            ###################################################################################
            ##
            ##                all other tabs
            ##
            ###################################################################################
            navbarPage('',
                       #######################################
                       ## heatmap of significant features
                       #######################################
                       tabPanel('Heatmap',
                                    fluidPage(
                                        fluidRow(
                                            column(1, h4('Column labels')),
                                            column(1, h4('Row labels')),
                                            column(9),
                                            column(1, h4('Export'))
                                        ),
                                        fluidRow(
                                            column(1, numericInput( "cexCol", "Size", value=12, min=1, step=1)),
                                            column(1, numericInput( "cexRow", "Size", value=8, min=1, step=1)),
                                            column(1, selectInput( "hm.scale", "Scale", c("row","column","none"), selected="none")),
                                            column(2, selectInput( "hm.clust", "Cluster", c("column","row","both","none"), selected="column")),
                                            column(2),
                                            column(1, checkboxInput('hm.max', 'Cap values', value=FALSE)),
                                            column(1, numericInput( "hm.max.val", "Max. value", value=4, step=1, min=2)),
                                            column(2),
                                            column(1, downloadButton('downloadHM', 'Download (pdf)'))
                                        ),
                                        tags$br(),
                                        tags$hr(),
                                        tags$br(),
                                        fluidRow(
                                            column(12, align='center', plotOutput("HM") )
                                        ),
                                        tags$br(),
                                        tags$hr(),
                                        tags$br()
                                    )
                                ),
                       ###################################################################################
                       ##              insert volcanos
                       ###################################################################################
                       do.call(navbarMenu, volc.tabs),

                       #######################################
                       ## PCA
                       #######################################
                       tabPanel('PCA',
                                     fluidPage(
                                         fluidRow(
                                             column(12, tags$h3('Principle component analysis:'))
                                         ),
                                         fluidRow(
                                             column(11),
                                             column(1, h4('Export'))
                                         ),
                                         fluidRow(
                                             column(11),
                                             column(1, downloadButton('downloadPCA', 'Download (pdf)'))
                                         ),
                                         tags$hr(),
                                         fluidRow(
                                             column(12, align='center', plotOutput("pca", width=1200, height=400) )
                                         ),
                                         tags$br(),
                                         tags$hr(),
                                         tags$br(),
                                         fluidRow(
                                                    column(1),
                                                    column(5, plotlyOutput("pca12.plotly", width=400, height=400) ),
                                                    column(5, plotlyOutput("pca23.plotly", width=400, height=400) ),
                                                    column(1)
                                         ),
                                         tags$br(),
                                         tags$hr()
                                     )
                                ),
                       #######################################
                       ## table preview
                       #######################################
                       tabPanel('Table',
                                    fluidPage(
                                        fluidRow(column(8, tags$h3('Result table (filtered):')), column(4, downloadButton('downloadExcel', 'Download (Excel)') )),## column(2, downloadButton('downloadExcel', 'Download (txt)') ) ),
                                        fluidRow( column(12, tags$br())),
                                        fluidRow(column(12, dataTableOutput("tableprev")))
                                    )
                                    ),


                       #######################################
                       ## QC
                       navbarMenu( "QC",
                                  ###########################
                                  ## boxplots
                                  tabPanel('Boxplots',
                                           fluidPage(
                                               fluidRow( column(12, plotOutput("expr.boxplot", width=1200, height=max( 30*(ncol( global.input$table)+2), 500)))),
                                               tags$br(),
                                               tags$hr(),
                                               tags$br(),
                                               if(!is.null(input$norm.data)) fluidRow(column(12, plotOutput("expr.boxplot.norm", width=1200, height=max( 30*(ncol( global.input$table)+2), 500)))),
                                               tags$br()
                                           )
                                           ),

                                  ## P-value distribution
                                  tabPanel('P-values',
                                           fluidPage(
                                               fluidRow(
                                                   column(12, plotOutput("pval.hist"))
                                               )
                                           )
                                           ),
                                  ############################
                                  ## correlation multiscatter
                                  tabPanel('Multi scatter',
                                           fluidPage(
                                               column(1, checkboxInput('ms.max', 'Define limits', value=FALSE)),
                                               column(1, numericInput( "ms.min.val", "min.", value=-4, step=1)),
                                               column(1, numericInput( "ms.max.val", "max.", value=4, step=1)),
                                               column(8),
                                               column(1, downloadButton('downloadMS', 'Download (pdf)'))
                                           ),
                                           tags$br(),
                                           tags$hr(),
                                           tags$br(),
                                           fluidPage(
                                               fluidRow(
                                                   column(12, plotOutput("multi.scatter"))
                                               )
                                           )
                                           ),
                                  #########################################################
                                  ## correlation multiscatte
                                  ##tabPanel('Testplot', fluidPage( fluidRow(column(12, plotOutput("testplot"))))),

                                  #########################################################
                                  ## correlation matrix
                                  tabPanel('Correlation matrix',

                                           fluidPage(
                                               fluidRow(
                                                   column(1,  selectInput( "cm.upper", "Upper triangle", c("pearson","spearman","kendall"), selected="pearson")),
                                                   column(1,  selectInput( "cm.lower", "Lower triangle", c("pearson","spearman","kendall"), selected="spearman")),
                                                   column(10)
                                               ),
                                               fluidRow(
                                                   column(11),
                                                   column(1, downloadButton('downloadCM', 'Download (pdf)'))
                                               )
                                           ),
                                           tags$br(),
                                           tags$hr(),
                                           tags$br(),
                                           fluidPage(
                                               fluidRow(
                                                   column(12, plotOutput("correlation.matrix"))
                                               )
                                           )
                                           )
                                  )

                        ) ## end navbarpage
        })

        #########################################################################################
        ##
        ##                                  user input
        ##
        #########################################################################################

        ######################################
        ## 1) file upload
        output$file.upload <- renderUI({

            if(!is.null(input$file)) return()
            if(!is.null( global.input$file)) return()

            ## generate 'session id'
            global.input$session <- paste(paste(letters[sample(26, 5)], collapse=''),paste(sample(100,5), collapse=''), sep='')

            ## upload form
            list(
                HTML('<font size=\"3\"><b>Upload file:</b></font>'),
                fileInput("file", "", accept=c('text/csv',
                       'text/comma-separated-values,text/plain',
                       '.csv', '.txt', '.tsv')),
                HTML('<hr border-width:\"10px\">')
            )
        })

        ######################################
        ## 3) pick id column
        output$choose.id.column <- renderUI({

            if(is.null(global.input$table)) return()
            if(!is.null(input$id.col))
                if(input$id.col > 0 && !is.null(input$id.col.value)) return()

            ## get uploaded table and column names
            tab <- global.input$table
            tab.colnames <- global.input$table.colnames

            ## try to find 'id' and move it to the first position
            id.idx <- grep('id|ID', tab.colnames)
            if(length(id.idx) > 0){
                tab.colnames <- c(tab.colnames[id.idx], tab.colnames[-id.idx])
            }

            ## radio button to pick id column
            list(
                ## experimental design
                downloadButton("exportTemplate", 'Export experimental design template'),
                HTML('<br><hr size=\"5\">'),
                radioButtons( "id.col.value", "Choose ID column", tab.colnames),
                actionButton("id.col", 'OK')
            )

        })

        ######################################
        ## 5) define groups
        output$define.groups <- renderUI({

            if(is.null(input$id.col)) return() ## no id colum
            if( !is.null(input$id.col))
                if( input$id.col == 0 ) return() ## not pressed yet
            if(!is.null(global.results$data)) return() ## test has been run
            if(!is.null(global.param$grp)){            ## group assignment has been RUN
                if(sum(is.na(global.param$grp)) == 0) return() ## group assignemnt has been DONE
            }

            ## number of assigned groups
            N.grp = global.param$N.grp + 1

            list(
                ## upload template
                fileInput("exp.file", "Upload experimental design file", accept=c('text/plain','.txt')),
                actionButton( 'update.grp', 'Next')
            )
        })

        ######################################
        ## filter type
        output$filter.type <- renderUI({
            if( (is.null(input$file) && (is.null(global.input$file )))| is.null(input$run.test)) return()
            if(!is.null(input$run.test)) if(input$run.test == 0) return()

            list(selectInput('filter.type', 'Filter based on:', c('nom.p', 'adj.p', 'top.n', 'none'), selected='adj.p'))
        })

        #####################################
        ## 6) select test
        output$list.groups <- renderUI({

            if( !global.param$grp.done ) return()
                list(
                    radioButtons('repro.filt', 'Reproducibility filter (beta)', choices=c('yes', 'no'), selected='no'),
                    radioButtons('norm.data', 'Data normalization', choices=c('Median', 'Median-MAD', '2-component', 'Quantile', 'none'), selected='none'),
                    radioButtons('which.test', 'Select test', choices=c('One-sample mod T', 'Two-sample mod T'), selected='One-sample mod T'),
                    actionButton('run.test', 'Run test!')
            )
        })

        ################################################################################################
        ##
        ##                              calculations
        ##
        ################################################################################################

        ###############################################
        ## 4) initialize group assignemnt
        observeEvent( input$id.col ,{

            if( is.null( global.input$table) | is.null(input$id.col.value) ) return()

            #############################################
            ## check the id column
            tab <- global.input$table
            ## make sure the ids are unique
            ids <- make.unique(as.character(tab[, input$id.col.value]), sep='_')
            tab[, input$id.col.value] <- ids
            rownames(tab) <- ids

            ########################################
            ## store
            global.input$table <-  tab

            #############################################
            ## initialize group assignemnt
            groups <- rep(NA, ncol(global.input$table))
            names(groups) <- colnames(global.input$table)

            ## remove id column
            groups <- groups[-c( which(input$id.col.value == names(groups))) ]

            ## set group assingment
            global.param$grp <- groups
            ## set number of assinged groups
            global.param$N.grp <- 0
        })

        ########################################
        ## 4b) update group assignment
        observeEvent( input$update.grp ,{

            label.grp.tmp = input$label.grp
            grp.tmp = input$groups

            ## current group assignment
            grp = global.param$grp
            ## update
            grp[ grp.tmp ] = label.grp.tmp
            global.param$grp <- grp

            ## check if done
            if(sum(is.na(grp)) == 0){
                global.param$grp.done = T
                ##global.param$grp.label = unique(grp)

                ## group colors
                grp.col <- rep(GRPCOLORS[1], length(grp))
                ##names(grp.col) <- names(grp)
                ##for(i in 2:global.param$N.grp) grp.col[ which(grp == unique(grp)[i]) ] <- GRPCOLORS[i]
                for(i in 2:length(unique(grp))) grp.col[ which(grp == unique(grp)[i]) ] <- GRPCOLORS[i]
                global.param$grp.colors <- grp.col
                ## group colors unique, e.g. to plot in a legend
                idx <- !duplicated(grp)
                grp.col.legend = grp.col[idx]
                names(grp.col.legend) <- grp[idx]
                global.param$grp.colors.legend <- grp.col.legend
            }
            ## update number of groups
            global.param$N.grp = length(unique( na.omit(grp)) )

        })
        ###############################################
        ## test data set
        observeEvent( input$testdata, {

            tab <- read.table( '/local/shiny-server/modT/testdata.txt', sep='\t', header=T, stringsAsFactors=F, na.strings=NASTRINGS  )

            global.input$table <- tab
            rm(tab)
            global.input$file  <- TRUE
        })


        #################################################################################
        ##
        ## 2) upload file
        ##
        #################################################################################
        observeEvent( input$file, {

                ##################################
                ## determine the separator
                tab.sep=NULL
                ## try to figure out the separator, DON'T USE THE HEADER FOR THAT
                ## use the fourth row instead (should be data)
                for(s in SEPARATOR){
                    tab <- read.table(input$file$datapath, sep=s, header=T, stringsAsFactors=F, nrows=1, skip=3)
                    ##tab <- tab[nrow(tab), ]
                    if(length(tab) > 1){
                        global.param$tabsep <- s
                        break;
                    }
                }
                ##cat('table separator:', as.character(global.param$tabsep),'test\n')
                ###########################################################
                ## import the table
                if( global.param$tabsep == '\t'){
                    tab <- read.delim( input$file$datapath, stringsAsFactors=F, na.strings=NASTRINGS)
                } else {
                    tab <- read.table( input$file$datapath, sep=global.param$tabsep, header=T, stringsAsFactors=F, na.strings=NASTRINGS, quote = "\"", dec = ".", fill = TRUE, comment.char = "")
                }
                ## store table
                global.input$table <- tab

                ## shorten column names and store together with the original names
                colnames.tmp <- chopString(colnames(tab), STRLENGTH)
                names(colnames.tmp) <- colnames(tab)
                global.input$table.colnames <- colnames.tmp

                rm(tab, colnames.tmp)
        })

        #################################################################
        ## 4c)       upload experimental design file
        ##
        ## - divide input table into expression and annotation columns
        observeEvent( input$exp.file, {

            ## reset error message
            error$msg <- NULL

            ## read the file
            grp.file <- read.delim(input$exp.file$datapath, header=T, stringsAsFactors=F)
            Column.Name <- grp.file$Column.Name
            Experiment <- grp.file$Experiment

            ###############################################################
            ## index on non-empty 'Experiment' rows
            exprs.idx <- which(nchar(Experiment) > 0 )

            ###############################################################
            ##
            ##                   do some sanity checks
            ##
            ###############################################################

            ## names in the exp design file do not match to the table
            if( sum( Column.Name != colnames(global.input$table)) > 0 ){
                error$msg <- 'Experimental design files does not match the table you have uploaded!'
                return()
            }

            ## not an experimental design file
            if( sum( colnames(grp.file) %in% c('Column.Name', 'Experiment'), na.rm=T) != 2 )  {
                error$msg <- 'This is not an experimental desgin file!\n\nThe file should contain two columns (Column.Name, Experiment)!'
                return()
            }
            ## 'empty' file
            if( sum( nchar(Experiment) > 0 ) == 0 | sum(!is.na( Experiment) == 0) ){
                error$msg <- 'No experiments defined!'
                return()
            }
            ##cat('L=', sum( Column.Name[ exprs.idx ] %in%  colnames(global.input$table)))
            ## column names specified in exp design file not found in table
            ##if( sum( Column.Name[ exprs.idx ] %in%  colnames(global.input$table)) != length(exprs.idx) ){
            ##    error$msg <- 'Column names in the experimental design file cannot be found in the data table!'
            ##    return()
           ## }
            ## check whether there are at least 2 replicates per group
            num.rep=table(Experiment[exprs.idx])
            if(min(num.rep) == 1){
                error$msg <- paste('No replicate measurements defined!')
                return()
            }


            ##################################
            ## ANNOTATION: extract empty cells
            ## - corresponding columns will be carried over as
            ##   annotation columns in the result file
            grp.anno <- grp.file[which(nchar(grp.file$Experiment) == 0 ), ]
            grp.anno <- setdiff( grp.anno$Column.Name, input$id.col.value )
            if(length(grp.anno)>0)
                global.input$table.anno <- global.input$table[ , grp.anno]

            ##cat('test')
            ##################################
            ## EXPRESSION
            ## - extract all non-empty cells in the 'Experiment' column
            grp.exprs <- grp.file[exprs.idx, ]

            ## class vector
            grp=grp.exprs$Experiment
            names(grp)=grp.exprs$Column.Name

            ## update input table, keep id and expression columns
            global.input$table <- global.input$table[ , c(input$id.col.value, names(grp))]


            ################################
            ## update number of groups
            global.param$N.grp <- length(unique( na.omit(grp)) )
            ## store group assignment
            global.param$grp <- grp
            ## group colors
            grp.col <- rep(GRPCOLORS[1], length(grp))
            for(i in 2:length(unique(grp))) grp.col[ which(grp == unique(grp)[i]) ] <- GRPCOLORS[i]
            global.param$grp.colors <- grp.col

            ## group colors for figure legend
            idx <- !duplicated(grp)
            grp.col.legend = grp.col[idx]
            names(grp.col.legend) <- grp[idx]
            global.param$grp.colors.legend <- grp.col.legend

            ## all done
            global.param$grp.done = T

        })

        ################################################################################
        ##
        ##            once the 'run test' button was pressed...
        ##
        ## 1) normalization (optional)
        ## 2) reproducibility filter (optional)
        ## 3) test
        ##
        ################################################################################
        observeEvent(input$run.test, {

            ##cat('run.test:', input$run.test, '\n')

            #####################################################################
            ## if the 'Run test' - button has been pressed for the first time,
            ## store a copy of the original input matrix (unnormalized, unfiltered)
            if (input$run.test == 1){
                global.input$table.org <- global.input$table
                tab <- global.input$table
            }
            if(input$run.test > 1 ){
                tab <- global.input$table.org
            }

            ## id column
            id.col = input$id.col.value
            ## all group labels
            groups=global.param$grp

            ##View(tab)

            ###############################################
            ## initialize values for normalized and filtered matrix
            global.results$table.norm=NULL
            global.results$table.repro.filt=NULL
            global.results$repro.filt=NULL
            global.results$pca=NULL

            ###############################################
            ## determine which test should be performed
            test = input$which.test
            norm.data = input$norm.data
            repro.filt = input$repro.filt

            ###############################################
            ## specify which comparisons should be performed
            if(test == 'One-sample mod T'){
                ## each group separetely
                groups.comp <- global.param$grp
                global.param$grp.comp <- groups.comp
            }
            if(test == 'Two-sample mod T'){
                ## all pairwise combinations
                groups.unique <- unique(global.param$grp)

                groups.comp <- c()
                count=1
                for(i in 1:(length(groups.unique)-1))
                    for(j in (i+1):length(groups.unique)){
                        groups.comp[count] <- paste(groups.unique[i], groups.unique[j], sep='.vs.')
                        count <- count+1
                    }
                global.param$grp.comp <- groups.comp
            }

            #############################################
            ## normalization
            #############################################
            if(norm.data != 'none'){
                ##tab.org = tab
                withProgress(message='Applying normalization...', {
                    tab <- normalize.data(tab, id.col, norm.data)
                    if(is.null(dim(tab))){
                    ##if(tab[1,1])
                        cat('dim  ',dim(tab), '\n',is.null(dim(tab)), '\n', tab, '\n')
                        ##if(unlist(tab) == 'No_sucess'){
                            View(tab)
                            error$msg <- 'Could not fit mixture model! Giving up...\n'
                        ##input$run.test <- NULL
                        ##break;
                            return()
                        ##}
                    }
                    global.results$table.norm <- tab
                })
            }
            ##############################################
            ##
            ## reproducibility filter
            ## - only for one-sample test
            ##
            ##############################################
            if(repro.filt == 'yes' & test == 'One-sample mod T'){

                withProgress(message='Applying reproducibility filter',  {
                    repro = my.reproducibility.filter(tab, id.col=id.col, groups, alpha=0.05)
                    tab = repro$table
                    ##View(repro$table)

                })
                ## store indices of filtered values in the original table
                global.results$repro.filt <- repro$values.filtered
                global.results$table.repro.filt <- tab
            }


            ########################################################################################
            ##
            ##                                     TEST
            ##
            ########################################################################################

            ##################################
            ## two sample
            if(test == 'Two-sample mod T'){

                withProgress(message='Two-sample test', value=0, {

                    count=0
                    ## loop over groups
                    for(g in unique(groups.comp)){

                        ## extract current groups
                        groups.tmp <- groups[grep(paste( unlist( strsplit(g, '\\.vs\\.')), collapse='|'  ) , groups) ]

                        ## progress bar
                        incProgress(1/length(unique(groups.comp)), detail=g)

                        ## extract table of current group
                        tab.group <- cbind(tab[, id.col], tab[, names(groups.tmp)])
                        colnames(tab.group)[1] <- id.col

                        #############################
                        ## the actual test
                        #############################
                        res.tmp <-  modT.test.2class( tab.group, groups=groups.tmp, id.col=id.col, label=g )$output
                        ##View(res.tmp)
                        if(count == 0){
                            res.comb <- res.tmp
                        } else {
                            ##res.comb <- merge(res.comb, res.tmp, sort=F)
                            ##res.comb <- merge(res.comb, res.tmp, by='id')

                            ## make sure the order is correct
                            if(nrow(res.tmp ) != nrow(res.comb)) stop( "number of rows don't match!\n" )
                            res.tmp <- res.tmp[rownames(res.comb), ]
                            res.comb <- cbind(res.comb, res.tmp)

                        }
                        ##View(res.comb)
                        count=count + 1

                    }

                ##################################
                ## reorder table
                res.id <- res.comb$id ## id column
                res.exprs <- res.comb[, names(groups)] ## expression values
                res.test <- res.comb[, grep('^logFC|^AveExpr|^t\\.|^P\\.Value|^adj.P.Val|^Log\\.P\\.Value', colnames(res.comb))] ## test results
                res.test <- res.test[, order(colnames(res.test))]

                ## assemble new table
                res.comb <- data.frame(id=res.id, res.test, res.exprs)
                ##res.comb <- res.comb[tab[, id.col], ]
                res.comb <- res.comb[rownames(tab),]
                ##View(tab)
                global.results$data$output <- res.comb

                })
            }
            ##################################
            ## one sample
            if(test == 'One-sample mod T'){
                cat('test...')
                withProgress(message='One-sample test', value=0, {

                    count=0
                    ## loop over groups
                    for(g in unique(groups.comp)){

                        ## progress bar
                        incProgress(1/length(unique(groups.comp)), detail=g)

                        ## extract table of current group
                        tab.group <- cbind(tab[, id.col], tab[, names(groups)[which(groups == g)]])
                        colnames(tab.group)[1] <- id.col

                        res.tmp <- modT.test( tab.group, id.col=id.col, plot=F, nastrings=NASTRINGS, label=g, na.rm=FALSE)$output
                        ##View(res.tmp)
                        if(count == 0){
                            res.comb <- res.tmp
                        } else {
                            if(nrow(res.tmp ) != nrow(res.comb)) stop( "number of rows don't match!\n" )
                            res.tmp <- res.tmp[rownames(res.comb), ]
                            res.comb <- cbind(res.comb, res.tmp)
                            ##res.comb <- merge(res.comb, res.tmp, sort=F)
                            ##res.comb <- merge(res.comb, res.tmp, by='id')
                        }
                        count=count + 1
                    }
                    ## add ids as rownames
                    ##rownames(res.comb) <- res.comb$id
                    colnames(res.comb) <- sub('^X', '', colnames(res.comb))
                })
                ##################################
                ## reorder table
                res.id <- res.comb$id ## id column
                res.exprs <- res.comb[, names(groups)] ## expression values
                res.test <- res.comb[, grep('^logFC|^AveExpr|^t\\.|^P\\.Value|^adj.P.Val|^Log\\.P\\.Value', colnames(res.comb))] ## test results
                res.test <- res.test[, order(colnames(res.test))]

                ## assemble new table
                res.comb <- data.frame(id=res.id, res.test, res.exprs)
                ##res.comb <- res.comb[tab[, id.col], ]
                res.comb <- res.comb[rownames(tab),]
                ###########################################
                ## store the results
                global.results$data$output <- res.comb
            }

            ############################
            ## initial filter
            ##filter.res()
            ##View(global.results$data$output)
            ##View(tab)


            ###################################################################
            ##
            ##              export result table to Excel
            ##
            ##
            ####################################################################
            tmp <- sort(global.param$grp)

            ## append annotation columns
            if(!is.null(global.input$table.anno))
                res.comb <- cbind(res.comb, Annotation.starts.here=rep('', nrow(res.comb)), global.input$table.anno)

            expDesign <- data.frame(Column=names(tmp), Experiment=tmp)

            withProgress(message='Generating result table...', {
                ## tab-delim
                ##write.table(res.comb, file=paste( TMPDIR, global.input$session, '.txt',sep=''), sep='\t', quote=F, na='', row.names=F)
                ## Excel
                 WriteXLS(c('res.comb', 'expDesign'), ExcelFileName=paste( TMPDIR, global.input$session, '.xlsx',sep=''), FreezeRow=1, FreezeCol=1, SheetNames=c('modT', 'class vector'), row.names=F, BoldHeaderRow=T, AutoFilter=T)

            })


            ###################################################################
            ##            insert the panels for the volcanos
            ###################################################################
           ins.volc()
        })

        ############################################################################
        ##
        ##     filter the test results accross multiple groups
        ##
        ############################################################################
        filter.res  <-  reactive({

            groups.comp=unique(global.param$grp.comp)

            ## test results
            res <- global.results$data$output

            #################################
            ## top N
            if(input$filter.type=='top.n'){

                if(length(groups.comp) > 1){
                    ## order according to p-value
                    res <- res[ order( unlist(apply( res[, grep('^P.Value', colnames(res) )], 1, min))  ), ]
                    res <- res[ 1:input$top.n, ]

                    ## order according to FC
                    res <- res[order( unlist(apply( res[, grep('^logFC', colnames(res) )], 1, min))  ), ]

                    ## now separate for each group comparison
                    res.groups <- lapply(groups.comp, function(g){
                        res.filt=res[ which(!is.na(paste('P.Value.', g, sep='') )), ]
                        res.filt=res.filt[ order( res.filt[, paste('P.Value.', g, sep='') ], decreasing=F) , ]
                        res.filt[1:input$top.n, ]
                    })
                    names(res.groups) <- groups.comp

                } else {
                     res <- res[order(res[, paste('P.Value.', groups.comp, sep='')]) , ]
                     res <- res[1:input$top.n, ]
                     res <- res[order(res[, paste('logFC.', groups.comp, sep='')]) , ]

                     res.groups <- list(res)
                     names(res.groups) <- groups.comp
                }
                global.results$filter.cutoff <- input$top.n
            }
            #################################
            ## nominal p-value
            if(input$filter.type=='nom.p'){
                if(length(groups.comp) > 1){
                    res <- res[ which( unlist(apply( res[, grep('^P.Value', colnames(res) )], 1, function(x) sum(x < input$p.val))) > 0), ]
                    res <- res[order( unlist(apply( res[, grep('^logFC', colnames(res) )], 1, min))  ), ]
                    ## now separate for each group comparison
                    res.groups <- lapply(groups.comp, function(g){
                        res[ which( res[, paste('P.Value.', g, sep='')] < input$p.val) , ]
                    })
                    names(res.groups) <- groups.comp
                } else {
                    res <- res[which(res[, paste('P.Value.', groups.comp, sep="")] < input$p.val), ]
                    res <-  res[order(res[, paste('logFC.', groups.comp, sep="")]), ]
                    res.groups <- list(res)
                    names(res.groups) <- groups.comp
                }
                global.results$filter.cutoff <- input$p.val
            }

            #################################
            ## adjusted p-value
            if(input$filter.type=='adj.p'){
                if(length(groups.comp) > 1){
                    res <- res[ which( unlist(apply( res[, grep('^adj.P.Val', colnames(res) )], 1, function(x) sum(as.numeric(x) < input$adj.p ))) > 0), ]
                    res <- res[order( unlist(apply( res[, grep('^logFC', colnames(res) )], 1, min))  ), ]
                    ## now separate for each group comparison
                    res.groups <- lapply(groups.comp, function(g){
                         res[ which( res[, paste('adj.P.Val.', g, sep='')] < input$adj.p) , ]
                    })
                    names(res.groups) <- groups.comp
                } else {
                    res <- res[which(res[, paste('adj.P.Val.', groups.comp,sep='')] < input$adj.p), ]
                    res <-  res[order(res[, paste('logFC.', groups.comp, sep="")]), ]
                    res.groups <- list(res)
                    names(res.groups) <- groups.comp
                }
                global.results$filter.cutoff <- input$adj.p
            }

            ###################################
            ## global FDR

            #################################
            ## no filter
            if(input$filter.type=='none'){
                global.results$filter.cutoff <- 'none'
                res.groups <- lapply(groups.comp, function(g) res)
                names(res.groups) <- groups.comp
            }

            ###################################################
            ## global filter accross all experiments
            global.results$filtered <- res
            global.results$filter.type <- input$filter.type
            global.results$filtered.groups <- res.groups

        })

        ###################################################################################################
        ##
        ##                                     output
        ##
        ###################################################################################################

        ##################################################
        ##
        ##           export the result table
        ##
        ##################################################
        ## Excel
        output$downloadExcel <- downloadHandler(
            filename = function(){ paste("results_", sub(' ', '_',input$which.test), '_', sub(' .*', '', Sys.time()), '_', input$norm.data, ifelse(input$repro.filt=='yes', paste('_reprofilt',sep=''), ''),".xlsx", sep='') },
            content = function(file){
                file.rename(paste( TMPDIR, global.input$session, '.xlsx', sep=''), file)
            }
        )
        ## tab delimited
        output$downloadTxt <- downloadHandler(
            filename = function(){ paste("results_", sub(' ', '_',input$which.test), '_', sub(' .*', '', Sys.time()), '_', input$norm.data, ifelse(input$repro.filt=='yes', paste('_reprofilt',sep=''), ''),".txt", sep='') },
            content = function(file){
                file.rename(paste( TMPDIR, global.input$session, '.txt', sep=''), file)
            }
        )

        #########################################
        ## download experimental design template
        output$exportTemplate <- downloadHandler(
            filename = function(){ 'experimentalDesign.txt' },
            content = function(file){
                tab <- global.input$table
                exp.design <- cbind(colnames(tab), rep('', ncol(tab)))
                colnames(exp.design) <- c('Column.Name', 'Experiment')
                write.table(  exp.design, file, sep='\t', quote=F, na='', row.names=F  )
            }
        )

        #####################################################################################
        ##
        ##             display the corresponding part of the table
        ##
        #####################################################################################
        output$tableprev <- renderDataTable({

            if(is.null(global.results$data)) return()

            filter.res()

            tab <- global.results$filtered
            colnames(tab) <- sub('^X','',colnames(tab))
            ##rownames(tab) <- tab[, input$id.col.value]

            ## check whether there is annotation stored
            if(!is.null(global.input$table.anno))
                    tab <- cbind(tab, global.input$table.anno[ rownames(tab), ])


            if(nrow(tab) > 0){
                ## add links to uniprot
                up.id <- tab[, 'id']
                up.link <- paste("<a href='http://www.uniprot.org/uniprot/", sub('(_|,|;).*', '', up.id),"' target='_blank'>", up.id, "</a>", sep='')
                tab[, 'id'] <- up.link
            }
            tab

        }, options = list( pageLength = 50), escape=F)


        #####################################################################################
        ##
        ##                             Volcano plot
        ##
        #####################################################################################

        ###################################################################
        ## function to generate the panels for the volcanos
        ## insert the plots into the webpage
        ###################################################################
        ins.volc <- reactive({

            grp.comp <- unique( global.param$grp.comp )

            for(i in 1:length(grp.comp)){
              local({
                  my_i <- i
                  ##########################
                  ## the actual plots
                  output[[paste("volcano", grp.comp[my_i], sep='.')]] <- renderPlot({
                      plotVolcano( grp.comp[my_i], max.logP=input$max.logP )
                  })

                  ##########################
                  ## download button
                  output[[paste("downloadVolcano", grp.comp[my_i], sep='.')]] <- downloadHandler(
                      filename = paste('volcano_', global.results$filter.type, '_', global.results$filter.cutoff, '.pdf', sep=''),
                      ##filename =  paste( 'volcano_',grp.comp[my_i],'.pdf'),
                      content = function(file){

                          pdf(file, height=11, width=11)

                          for(j in 1:length(grp.comp)){
                              local({
                                  my_j=j
                                  plotVolcano(grp.comp[my_j], max.logP=input$max.logP)
                              })
                          }
                          dev.off()
                      }
                  ) ## end download handler

                  ##################################
                  ## info table
                  output[[paste('info', grp.comp[my_i], sep='.')]] <-  renderTable({
                      if(is.null(global.results$data)) return()
                      res <- as.data.frame( global.results$data$output )
                      text.tmp <- nearPoints(res, input[[paste('plot_hover', grp.comp[my_i], sep='.')]], threshold=10, maxpoints =  1, xvar=paste('logFC', grp.comp[my_i], sep='.'), yvar=paste('Log.P.Value', grp.comp[my_i], sep='.'))
                      text.tmp <- text.tmp[, c('id', paste('logFC', grp.comp[my_i], sep='.'), paste('P.Value',grp.comp[my_i], sep='.'), paste('adj.P.Val', grp.comp[my_i], sep='.'))]
                      rownames(text.tmp) <- NULL
                      if( nrow(text.tmp) == 1 )
                          text.tmp
                      else{
                          text.tmp[1, ] <- rep(' ', ncol(text.tmp))
                          text.tmp
                      }
                  })

                  ##################################
                  ## observe clicks
                  observeEvent(input[[paste('plot_click', grp.comp[my_i], sep='.')]], {
                      res <- as.data.frame( global.results$data$output )
                      ##group.comp <- unique(global.param$grp.comp)

                      text.tmp <- nearPoints(res, input[[paste('plot_click', grp.comp[my_i], sep='.')]], threshold=10, maxpoints =  1, xvar=paste('logFC', grp.comp[my_i], sep='.'), yvar=paste('Log.P.Value', grp.comp[my_i], sep='.'))

                      if(nrow(text.tmp) == 1){
                          ################################################
                          ## first click
                          if(is.null(volc[[ paste('x', grp.comp[my_i], sep='.')]] )){
                              volc[[paste('x', grp.comp[my_i], sep='.')]] = text.tmp[paste('logFC', grp.comp[my_i], sep='.')]
                              volc[[paste('y', grp.comp[my_i], sep='.')]] = text.tmp[paste('Log.P.Value', grp.comp[my_i], sep='.')]
                              volc[[paste('text', grp.comp[my_i], sep='.')]] = text.tmp['id']
                              volc[[paste('xy', grp.comp[my_i], sep='.')]] = paste(text.tmp[paste('logFC', grp.comp[my_i], sep='.')], text.tmp[paste('Log.P.Value', grp.comp[my_i], sep='.')])
                              volc[[paste('P.Value', grp.comp[my_i], sep='.')]] <- text.tmp[paste('P.Value', grp.comp[my_i], sep='.')]
                              volc[[paste('adj.P.Val', grp.comp[my_i], sep='.')]] <- text.tmp[paste('adj.P.Val', grp.comp[my_i], sep='.')]
                          } else {
                              ######################################################
                              ## REMOVE: check if point is present already
                              if( paste(text.tmp[paste('logFC', grp.comp[my_i], sep='.')], text.tmp[paste('Log.P.Value', grp.comp[my_i], sep='.')]) %in% volc[[paste('xy', grp.comp[my_i], sep='.')]]){

                                  ## if so remove from the list
                                  idx = which( volc[[paste('xy', grp.comp[my_i], sep='.')]] == paste(text.tmp[paste('logFC', grp.comp[my_i], sep='.')], text.tmp[paste('Log.P.Value', grp.comp[my_i], sep='.')]))

                                  if(length(volc[[paste('xy', grp.comp[my_i], sep='.')]] > 1)){
                                      volc[[paste('x', grp.comp[my_i], sep='.')]] <- volc[[paste('x', grp.comp[my_i], sep='.')]][-idx]
                                      volc[[paste('y', grp.comp[my_i], sep='.')]] <- volc[[paste('y', grp.comp[my_i], sep='.')]][-idx]
                                      volc[[paste('text', grp.comp[my_i], sep='.')]] <- volc[[paste('text', grp.comp[my_i], sep='.')]][-idx]
                                      volc[[paste('xy', grp.comp[my_i], sep='.')]] <- volc[[paste('xy', grp.comp[my_i], sep='.')]][-idx]
                                      volc[[paste('P.Value', grp.comp[my_i], sep='.')]] <- volc[[paste('P.Value', grp.comp[my_i], sep='.')]][-idx]
                                      volc[[paste('adj.P.Val', grp.comp[my_i], sep='.')]] <- volc[[paste('adj.P.Val', grp.comp[my_i], sep='.')]][-idx]
                                  } else {
                                      volc[[paste('text', grp.comp[my_i], sep='.')]] <- volc[[ paste('y', grp.comp[my_i], sep='.') ]] <- volc[[paste('x', grp.comp[my_i], sep='.')]] <- volc[[paste('xy', grp.comp[my_i], sep='.')]] <- volc[[paste('adj.P.Val', grp.comp[my_i], sep='.')]] <- volc[[paste('P.Value', grp.comp[my_i], sep='.')]]<- NULL
                                                    }
                                  ################################################
                                  ## ADD: if selected point is not present add it to the list
                              } else{
                                  volc[[paste('x', grp.comp[my_i], sep='.')]]=c( volc[[paste('x', grp.comp[my_i], sep='.')]],
                                                                      text.tmp[paste('logFC', grp.comp[my_i], sep='.')])
                                  volc[[paste('y', grp.comp[my_i], sep='.')]]=c(volc[[paste('y', grp.comp[my_i], sep='.')]], text.tmp[paste('Log.P.Value', grp.comp[my_i], sep='.')])
                                  volc[[paste('text', grp.comp[my_i], sep='.')]]=c(volc[[paste('text', grp.comp[my_i], sep='.')]],  text.tmp[ 'id'] )
                                  volc[[paste('xy', grp.comp[my_i], sep='.')]] = c(volc[[paste('xy', grp.comp[my_i], sep='.')]], paste(text.tmp[paste('logFC', grp.comp[my_i], sep='.')], text.tmp[paste('Log.P.Value', grp.comp[my_i], sep='.')]) )

                                  volc[[paste('P.Value', grp.comp[my_i], sep='.')]]=c(volc[[paste('P.Value', grp.comp[my_i], sep='.')]],  text.tmp[paste('P.Value', grp.comp[my_i], sep='.')] )
                                  volc[[paste('adj.P.Val', grp.comp[my_i], sep='.')]]=c(volc[[paste('adj.P.Val', grp.comp[my_i], sep='.')]],  text.tmp[paste('adj.P.Val', grp.comp[my_i], sep='.')] )
                              }
                          }
                      }
                  }) ## end observe clicks

                  ######################################################
                  ## table of selected features
                  output[[paste('volc.tab.selected', grp.comp[my_i], sep='.')]] <- renderTable({

                      if(is.null(volc[[paste('x', grp.comp[my_i], sep='.')]])) return()
                      if(length(volc[[paste('x', grp.comp[my_i], sep='.')]]) == 0) return()
                      tags$h4('Selection:')

                      id.tmp <- volc[[paste('text', grp.comp[my_i], sep='.')]]
                      ## dat.select = data.frame(id=unlist(volc[[paste('text', grp.comp[my_i], sep='.')]]), logFC=unlist(volc[[paste('x', grp.comp[my_i], sep='.')]]), xy=unlist(volc[[paste('xy', grp.comp[my_i], sep='.')]]))
                       dat.select = data.frame(id=unlist(volc[[paste('text', grp.comp[my_i], sep='.')]]), logFC=unlist(volc[[paste('x', grp.comp[my_i], sep='.')]]), P.Value=unlist(volc[[paste('P.Value', grp.comp[my_i], sep='.')]]), adj.P.Value=unlist(volc[[paste('adj.P.Val', grp.comp[my_i], sep='.')]]) )
                      up.id <- dat.select[, 'id']
                      up.link <- paste("<a href='http://www.uniprot.org/uniprot/", sub('(_|,|;).*', '', up.id),"' target='_blank'>", up.id, "</a>", sep='')
                      dat.select[, 'id'] <- up.link

                      dat.select
                  }, sanitize.text.function = function(x) x)



              }) ## end local

            } ## end for loop

        })

        ############################################
        ## actual plot
        plotVolcano <- function(group, max.logP = 100){

            ## apply filter
            filter.res()


            ## pch for significant points
            sig.pch=18

            ## unfiltered
            res = as.data.frame( global.results$data$output )
            ##rownames(res) <- res[, input$id.col.value]
 ## filtered
            res.filt = as.data.frame(global.results$filtered.groups[[group]])
            ##rownames(res.filt) <- res.filt$id

            ## extract fc and p
            logFC <- res[, paste('logFC.', group, sep='')]
            logPVal <- res[, paste('Log.P.Value.', group, sep='')]

            ## index of missing values
            rm.idx <- union( which(is.na(logFC)), which(is.na(logPVal)) )
            if(length(rm.idx) > 0){
                res <- res[-rm.idx, ]
                logFC <- logFC[-rm.idx]
                logPVal <- logPVal[-rm.idx]
            }

            ## which filter?
            filter.str <- paste('filter:', global.results$filter.type, '\ncutoff:', global.results$filter.cutoff)

            ######################################################################
            ## extract significant proteins of current group/test
            if(global.results$filter.type == 'top.n'){
                PVal <- res[, paste('P.Value.', group, sep='')]
                sig.idx = order(PVal, decreasing=F)[1:global.results$filter.cutoff]
            }
            if(global.results$filter.type == 'nom.p'){
                PVal <- res[, paste('P.Value.', group, sep='')]
                sig.idx = which(PVal <= global.results$filter.cutoff)
            }
            if(global.results$filter.type == 'adj.p'){
                adjPVal <- res[, paste('adj.P.Val.', group, sep='')]
                sig.idx = which(adjPVal <= global.results$filter.cutoff)
            }
            if(global.results$filter.type == 'none')
                sig.idx = 1:length(logFC)

            pch.vec=rep(19, nrow(res))
            cex.vec=rep( input[[paste('cex.volcano', group, sep='.')]], nrow(res))

            if(length(sig.idx) > 0){
                pch.vec[sig.idx] <- sig.pch
                cex.vec[sig.idx] <- cex.vec[1]+1


            ###################################
            ## set maximal log p value
            if(!is.null( max.logP))
                logPVal[which(logPVal > max.logP)] <- max.logP

            }

            #############################
            ## color gradient
            ##cat('# NA:',sum(is.na(logPVal)),'\n', sum(is.na(na.omit( logPVal))), '\n')
            col=myColorRamp(c('black', 'grey20', 'darkred', 'red', 'deeppink'), na.omit(logPVal), range=c(0, max.logP))
            ##col='blue'

            ## limits
            xlim = max(abs(logFC), na.rm=T)
            ##xlim <- max( abs(res), na.rm=T)
            xlim = xlim + xlim*.1
            xlim = c(-xlim, xlim)

            ##
            ylim = ifelse(is.null(max.logP), max(logPVal, na.rm=T), max.logP)
            ylim = c(0, ylim+.2*ylim)


            ####################################################
            ## plot
            par(mar=c(4,5,5,2))
            plot.new()
            plot.window( xlim=xlim, ylim=ylim, cex.axis=1.8, cex.lab=1.8)
            ## title
            mtext(group, side=3, cex=2, line=2)
            ## label axes
            mtext(expression(log(FC)), side=1, cex=1.8, line=3)
            mtext(expression(-10*log[10](P-value)), side=2, cex=1.8, line=3)
            ## draw axes
            axis(1, cex.axis=1.8)
            axis(2, las=2, cex.axis=1.8)
            ## grid
            if( input[[paste('grid.volcano', group, sep='.')]] )
                grid()
            ## actual plot
            points(logFC, logPVal, col=col, pch=pch.vec, cex=cex.vec)
            ## add filter
            abline(h=min(logPVal[sig.idx], na.rm=T), col='grey30', lwd=2, lty='dashed')
            text( xlim[2]-(xlim[2]*.05), min(logPVal[sig.idx], na.rm=T), paste(global.results$filter.type, global.results$filter.cutoff, sep='='), pos=3, col='grey30')
            ## number of significant
            legend('top', bty='n', legend=paste(filter.str, '\nsig / tot: ', length(sig.idx),' / ', sum(!is.na(logFC) & !is.na(logPVal)), sep=''), cex=1.5)

            ## up/down
            ##legend('topleft', legend=paste('\n', sum()))
            ## add selected points
            if(!is.null( volc[[paste('x', group, sep='.')]] ) & length(volc[[paste('x', group, sep='.')]]) ){
                for(i2 in 1:length(unlist(volc[[paste('x', group, sep='.')]])))
                   text(unlist(volc[[paste('x', group, sep='.')]][i2]), unlist(volc[[paste('y', group, sep='.')]][i2]), unlist(volc[[paste('text', group, sep='.')]][i2]),pos=ifelse(volc[[paste('x', group, sep='.')]][i2] < 0, 2, 4), cex=input[[paste('cex.volcano.lab', group, sep='.')]])
            }
            ##if( input[[paste('grid.volcano', group, sep='.')]] )
            ##    grid()
        }

        #######################################################################################
        ##
        ##                                    boxplots
        ##
        #######################################################################################

        ######################################
        ## without normalization
        output$expr.boxplot <- renderPlot({

            if(is.null(global.results$data)) return()

            ## dataset
            tab <- global.input$table
            ## id column
            id.col <- input$id.col.value
            ## group vector
            grp <- global.param$grp
            ## group colors
            grp.col <- global.param$grp.colors
            grp.col.leg <- global.param$grp.colors.legend

            makeBoxplot(tab, id.col, grp, grp.col, grp.col.leg)
        } ##,
        ##width = function(){ width=1000},
        ##height= function(){ height=max( 30*(ncol( global.input$table)+2), 500) } )
        )
        #################################################
        ## with normalization
        output$expr.boxplot.norm <- renderPlot({

            if(is.null(global.results$data)) return()
            if(is.null(global.results$table.norm)) return()

            ## dataset
            tab <- global.results$table.norm
            ## id column
            id.col <- input$id.col.value
            ## group vector
            grp <- global.param$grp
            ## group colors
            grp.col <- global.param$grp.colors
            grp.col.leg <- global.param$grp.colors.legend

            makeBoxplot(tab, id.col, grp, grp.col, grp.col.leg, legend=F)
        }##,
        ##width = function(){ width=1000},
        ##height= function(){ height=max( 30*(ncol( global.input$table)+2), 500) } )
        )
        ######################################################################################
        ##
        ##                                   Correlation
        ##
        ######################################################################################
        output$multi.scatter <- renderPlot({
            if(is.null(global.results$data)) return()
            plotMultiScatter( define.max=input$ms.max, min.val=input$ms.min.val, max.val=input$ms.max.val )
        },
        width = function(){120*(ncol(global.input$table)-1)},
        height= function(){120*(ncol(global.input$table)-1)}
        )

        ###############################
        ## actual plot
        plotMultiScatter <- function(define.max, min.val, max.val){
            ## dataset
            tab <- global.input$table
            ## id column
            id.col <- input$id.col.value
            rownames(tab) <- tab[, id.col]
            ## table
            tab <- tab[, setdiff(colnames(tab), id.col)]
            ## get groups
            grp <-  global.param$grp
            grp <- sort(grp)
            tab <- tab[, names(grp)]

            ## mapping to colors
            ##grp.col <- rep('grey10', length(grp))
            ##grp.col[which(grp == input$label.g2)] <- 'darkblue'

            colnames(tab) <- chopString(colnames(tab), STRLENGTH)

            ##input$ms.max
            ##input$ms.max.val

            ###############################
            ## plot
            withProgress({
                setProgress(message = 'Processing...', detail= 'Calculation correlations')
                my.multiscatter(tab, repro.filt=global.results$repro.filt, grp=grp,  grp.col.legend=global.param$grp.colors.legend, define.max=define.max, max.val=max.val, min.val=min.val)
            })
        }
        ################################
        ## download image, Multiscatter
        output$downloadMS <- downloadHandler(
            filename =  paste( 'multiscatter.pdf'),
            content = function(file){
                pdf(file, height=100*ncol(global.input$table)*(11/800), width=100*ncol(global.input$table)*(11/800))
                plotMultiScatter(define.max=input$ms.max, max.val=input$ms.max.val, min.val=input$ms.min.val)
                dev.off()
            }
        )

        #####################################################
        ## correlation matrix
        output$correlation.matrix <- renderPlot({
            if(is.null(global.results$data)) return()
                    plotCorrMat(lower=input$cm.lower, upper=input$cm.upper)
        }, width=1200, height=1000)
        ###################################################
        ## correlation matrix
        ###################################################
        plotCorrMat <- function(filename=NA, lower=c('pearson', 'spearman', 'kendall', 'pcor'), upper=c('pearson', 'spearman', 'kendall', 'pcor')){

            ## dataset
            tab <- global.input$table
            ## id column
            id.col <- input$id.col.value
            ## class vector
            grp <- sort(global.param$grp)
            grp.col.legend <- global.param$grp.colors.legend

            ## table
            tab <- tab[, setdiff(colnames(tab), id.col)]
            tab <- tab[, names(grp)]

            ###########################
            ## calculate correlations
            withProgress({
                setProgress(message = 'Processing...', detail= 'Calculation correlations')
                            cm.upper <- cor(tab, use='pairwise', method=match.arg(upper))
                            cm.lower <- cor(tab, use='pairwise', method=match.arg(lower))
            })
            ###########################
            ## initialize correlation matrix
            cm <- matrix(NA, ncol=ncol(cm.upper),nrow=nrow(cm.upper), dimnames=dimnames(cm.upper))
            cm[ lower.tri(cm, diag=T) ] <- cm.lower[lower.tri(cm.lower, diag=T)]
            cm[ upper.tri(cm, diag=F) ] <- cm.upper[upper.tri(cm.upper, diag=F)]

            ## colors
            color.breaks = seq(-1, 1, length.out=10)
            color.hm=colorRampPalette(c('blue', 'grey80' , 'red'))(length(color.breaks))

            ## gaps between groups
            gaps.column=cumsum(table(grp))
            gaps.row=gaps.column

            ## annotation of rows/columns
            anno=data.frame(Group=grp)
            anno.color=list(Group=grp.col.legend)

            Rowv=F
            Colv=F

            ##setHook("grid.newpage", function() pushViewport(viewport(x=1,y=1,width=0.9, height=0.9, name="vp", just=c("right","top"))), action="prepend")
            setHook("grid.newpage", function() pushViewport(viewport(x=1,y=1,width=0.9, height=0.9, name="vp", just=c("right","top"))))
            pheatmap(cm, fontsize_row=10, fontsize_col=10,
                     cluster_rows=Rowv, cluster_cols=Colv, border_col=NA, col=color.hm, filename=filename, labels_col=chopString(colnames(cm), STRLENGTH), labels_row=chopString(rownames(cm), STRLENGTH), main='', annotation_col=anno, annotation_colors=anno.color,  annotation_row=anno, display_numbers=T, fontsize_number=100/ncol(cm)+10, breaks=color.breaks, gaps_col=gaps.column, gaps_row=gaps.row)
            setHook("grid.newpage", NULL, "replace")

            ## add corr coeff
            grid.text(paste(match.arg(upper)), y=.995, x=.4, gp=gpar(fontsize=25))
            grid.text(paste(match.arg(lower)), x=-0.01, rot=90, gp=gpar(fontsize=25))
        }
        ##################################################################
        ## download correlation matrix
        output$downloadCM <- downloadHandler(
            filename =  paste( 'corrmat_', paste(unique(c(input$cm.lower, input$cm.upper)), collapse='_'), '.pdf', sep=''),
            content = function(file){
                pdf(file, height=1000*(11/800), width=1200*(11/800))
                plotCorrMat(filename=NA, lower=input$cm.lower, upper=input$cm.upper)
                dev.off()
            }
        )

        ####################################################################################
        ##
        ##                                  Heatmap
        ##
        ####################################################################################
        output$HM <- renderPlot({
            if(is.null(global.results$data)) return()

            if(input$hm.max){
                plotHM(cellwidth=40, max.val=input$hm.max.val)
            } else {
                plotHM(cellwidth=40)
            }
        },
        width = function(){ max(50*length(global.param$grp), 1000) },
        height= function(){
            filter.res()
            height=min( dynamicHeightHM( nrow(global.results$filtered)), 1500 )
            return(height)}
        )
        #######################################
        ## actual plot
        plotHM <- function(filename=NA, cellwidth=NA, cellheight=NA, max.val=NA){

            ## groups
            ## grp = global.results$data$groups
            grp=global.param$grp
            grp.col <- global.param$grp.colors
            grp.col.legend <- global.param$grp.colors.legend

            filter.res()
            res = global.results$filtered

            ## extract expression values
            res = res[, names(grp)]

            ## which filter has been used
            filter.str <- paste('filter:', global.results$filter.type, ' / cutoff:', global.results$filter.cutoff, sep='')

            if(nrow(res) < 3) return()
            colnames(res) <- sub('^X','', colnames(res) )

            ## convert to data matrix
            res <- data.matrix(res)

            #########################################
            ## scaling
            if(input$hm.scale == 'row')
                res <- t(apply(res, 1, function(x)(x-mean(x, na.rm=T))/sd(x, na.rm=T)))
            if(input$hm.scale == 'column')
                res <- apply(res, 2, function(x)(x-mean(x, na.rm=T))/sd(x, na.rm=T))

            ##########################################
            ##          cluster
            ## 20160309 NA handling
            ##
            ##########################################
            na.idx.row <- na.idx.col <- NULL
            ## column clustering
            if(input$hm.clust == 'column'){
                Rowv=FALSE
                colv.dist = dist(t(res), method='euclidean', diag=T, upper=T)
                na.idx.col <- which(apply(as.matrix(colv.dist), 1, function(x) sum(is.na(x))) > 0)
                if(length(na.idx.col)> 0){
                    colv.dist <- colv.dist[-na.idx.col, ]
                    colv.dist <- colv.dist[, -na.idx.col]
                }
                Colv=hclust(as.dist(colv.dist), method='complete')
                ##Colv = hclust( colv.dist, method='complete')
                ##Colv = hclust( dist(t(res), method='euclidean'), method='complete' )
                ##Colv=as.dendrogram( colv.clust )
                ##Colv=TRUE

            ## row clustering
            } else if(input$hm.clust == 'row'){
                ##Rowv=TRUE
                ##Rowv=as.dendrogram( hclust( dist(res, method='euclidean'), 'complete') )
                ##Rowv=hclust( dist(res, method='euclidean'), 'complete')
                rowv.dist <- as.matrix(dist(res, method='euclidean', diag=T, upper=T))
                na.idx.row <- which(apply(as.matrix(rowv.dist), 1, function(x) sum(is.na(x))) > 0)
                if(length(na.idx.row)> 0){
                    rowv.dist <- rowv.dist[-na.idx.row, ]
                    rowv.dist <- rowv.dist[, -na.idx.row]
                }
                Rowv=hclust(as.dist(rowv.dist), method='complete')
                Colv=FALSE

            ## row and column clustering
            } else if(input$hm.clust == 'both'){

                ## row clustering
                rowv.dist <- as.matrix(dist(res, method='euclidean', diag=T, upper=T))
                na.idx.row <- which(apply(as.matrix(rowv.dist), 1, function(x) sum(is.na(x))) > 0)
                if(length(na.idx.row)> 0){
                    rowv.dist <- rowv.dist[-na.idx.row, ]
                    rowv.dist <- rowv.dist[, -na.idx.row]
                }
                Rowv=hclust(as.dist(rowv.dist), method='complete')

                ## column clustering
                colv.dist = dist(t(res), method='euclidean', diag=T, upper=T)
                na.idx.col <- which(apply(as.matrix(colv.dist), 1, function(x) sum(is.na(x))) > 0)
                if(length(na.idx.col)> 0){
                    colv.dist <- colv.dist[-na.idx.col, ]
                    colv.dist <- colv.dist[, -na.idx.col]
                }
                Colv=hclust(as.dist(colv.dist), method='complete')
                ##Rowv=hclust( dist(res, method='euclidean'), 'complete')
                ##Colv=hclust( dist(t(res), method='euclidean'), 'complete')

            } else {
                Rowv=Colv=FALSE
            }

            #########################################
            ## capping
            if(!is.na(max.val)){
                res[ res < -max.val ] <- -max.val
                res[ res > max.val ] <- max.val
            }
            #########################################
            ## min/max value
            max.val = ceiling( max( abs(res), na.rm=T) )
            min.val = -max.val

            ##########################################
            ## colors
            color.breaks = seq( min.val, max.val, length.out=12 )
            color.hm = rev(brewer.pal (length(color.breaks)-1, "RdBu"))

            ##############################################
            ## annotation of columns
            anno.col=data.frame(Group=grp)
            anno.col.color=list(Group=grp.col.legend)

            ##############################################
            ## heatmap title
            hm.title = paste(filter.str, '\nsig / total: ', nrow(res), ' / ', nrow(global.input$table),sep='')
            if(!is.null(na.idx.row) | !is.null(na.idx.col))
                hm.title = paste(hm.title, '\nremoved rows / columns: ', length(na.idx.row), ' / ' , length(na.idx.col), sep='')

           ############################################
           ## heatmap
           pheatmap(res, fontsize_row=input$cexRow, fontsize_col=input$cexCol,
                     cluster_rows=Rowv, cluster_cols=Colv, border_col=NA, col=color.hm, filename=filename, main=hm.title, annotation_col=anno.col, annotation_colors=anno.col.color, labels_col=chopString(colnames(res), STRLENGTH), breaks=color.breaks, scale='none', cellwidth=cellwidth, cellheight=cellheight)
        }

        #####################################
        ## download image
        output$downloadHM <- downloadHandler(
            filename =  paste( 'heatmap.pdf'),
            content = function(file){

                if(input$hm.max){
                    plotHM(filename=file, cellheight=min( dynamicHeightHM( nrow(global.results$filtered)), 1500 )/nrow(global.results$filtered), cellwidth=40, max.val=input$hm.max.val)
                } else {
                    plotHM(filename=file, cellheight=min( dynamicHeightHM( nrow(global.results$filtered)), 1500 )/nrow(global.results$filtered), cellwidth=40)
                }
            }
        )

        #####################################################################################
        ## histogram of p-values
        #####################################################################################
        output$pval.hist <- renderPlot({

            if(is.null(global.results$data)) return()
            groups.comp <- unique(global.param$grp.comp)

            res = global.results$data$output

            par(mfrow=c(length(groups.comp),1))
            for(g in groups.comp){

                pval <- res[, paste('P.Value', g, sep='.')]
                hist(pval, breaks=50, main=paste('Histogram of P-values (N=', sum(!is.na(pval)), ')',sep=''), xlab='P-value', cex.main=3, cex.axis=2, cex.lab=2, col='darkblue', border=NA)
                legend('top', legend=g, cex=2)
            }
        },
        width = function(){ width=1000},
        height= function(){ height=500*length(unique(global.param$grp.comp))} )

        ######################################################################################
        ##
        ##                                 PCA
        ##
        ######################################################################################
        output$pca <- renderPlot({
            if(is.null(global.results$data) | is.na(input$top.n)) return()

              withProgress(message = 'PCA...',{
                    pca=plotPCA()
                  })
            ## store results
            global.results$pca <- pca
        })

        ##################################
        ## plot_ly PC1 vs. PC2
        output$pca12.plotly <- renderPlotly({
            if(is.null(global.results$data) | is.na(input$top.n) | is.null(global.results$pca)) return()

            pca <- global.results$pca
            pca.mat = data.frame(
                PC1=pca$x[,1],
                PC2=pca$x[,2]
            )
            rownames(pca.mat) <- rownames(pca$x)

            p <- plot_ly( pca.mat, x=PC1, y=PC2, type='scatter', mode='markers', marker=list(size=20, color=global.param$grp.colors), text=chopString(rownames(pca.mat), STRLENGTH) )
            p <- layout(p, title='PC1 vs. PC2')

        })
        ##################################
        ## plot_ly PC2 vs. PC3
        output$pca23.plotly <- renderPlotly({
            if(is.null(global.results$data) | is.na(input$top.n) | is.null(global.results$pca)) return()
            ##pca=plotPCA(plot=F)
            pca <- global.results$pca
            pca.mat = data.frame(
                PC3=pca$x[,3],
                PC2=pca$x[,2]
            )
            rownames(pca.mat) <- rownames(pca$x)

            p <- plot_ly( pca.mat, x=PC2, y=PC3, type='scatter', mode='markers', marker=list(size=20, color=global.param$grp.colors), text=chopString(rownames(pca.mat), STRLENGTH) )
            p <- layout(p, title='PC2 vs. PC3')

        })


        ###############################################
        ## static PCA plot
        ###############################################
        plotPCA <- function(plot=T){

            filter.res()

            res <- global.results$filtered

            if(nrow(res) < 3) return()

            ## get groups
            grp <- global.param$grp
            ## mapping to colors
            grp.col <- global.param$grp.colors
            grp.col.leg <- global.param$grp.colors.legend

            ## remove missing values
            rm.idx <- apply(res, 1, function(x) sum(is.na(x)) + sum(is.infinite(x)))
            rm.idx <- which(rm.idx > 0)
            if(length(rm.idx)>0) res <- res[-rm.idx, ]
            if(nrow(res) < 3) return()

            ## plot
            pca <- my.prcomp(t(res[, names(grp)]), col=grp.col, plot=plot, rgl=F, main='', cex.points=5, leg.vec=names(grp.col.leg), leg.col=grp.col.leg)


            return(pca)
        }

        #######################################################
        ## download PCA
        output$downloadPCA <- downloadHandler(
            filename = paste('pca_', global.results$filter.type, '_', global.results$filter.cutoff, '.pdf', sep=''),
            ##filename =  paste( 'pca.pdf'),
            content = function(file){
                withProgress(message='Exporting PCA...',{
                    pdf(file, height=5, width=15)
                    pca=plotPCA()
                    dev.off()
                })
            }
        )



        ################################################################################################
        ## used for debugging purposes
        output$testplot <- renderPlot({

            if(is.null(global.results$data) | is.na(input$top.n)) return()

            tab <- global.input$table

            grp <- global.param$grp
            grp <- grp[which(grp==grp[1])]


            repro.ids <- global.results$repro.filt[[unique(grp)]]

            ##tab.repro <- tab[ repro.ids, names(grp) ]

            tab <- tab[, names(grp)]


            ba <-  bland.altman.stats(as.numeric( as.character( tab[, 1 ]) ), as.numeric( as.character( tab[,  2 ] )) )

            par(mfrow=c(1,2))
            ba2 <-  bland.altman.plot(as.numeric( as.character( tab[, 1 ]) ), as.numeric( as.character( tab[,  2 ] )) )

            ##View(tab[repro.ids, ])
            ##View( global.results$table.repro.filt[repro.ids, names(grp)] )

            repro.idx2 <- union( which(ba$diffs < ba$lower.limit), which(ba$diffs > ba$upper.limit))

            mydiff <- tab[, 1] - tab[, 2]

            ##cat( tab[1:5,2], '\n', tab[1:5, 1], '\n\n', ba$diffs[1:5], '\n\n')
            ##cat(mydiff[1:5], '\n')
            ##cat('\n\n', colnames(tab)[1:2],'\n')


            repro.idx3 <- which(mydiff < ba$lower.limit | mydiff > ba$upper.limit)

            ##cat(repro.idx2)
            plot(  tab[,1], tab[, 2] )
            ##points( tab[repro.ids, 1], tab[repro.ids, 2], col='red' )
            points( tab[repro.idx2, 1], tab[repro.idx2, 2], col='blue' )
            points( tab[repro.idx3, 1], tab[repro.idx3, 2], col='green' )



        })

})


###########################################################
