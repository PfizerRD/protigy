{
    "collab_server" : "",
    "contents" : "################################################################################################################\n## Filename: global.r\n## Created: October 09, 2015\n## Author(s): Karsten Krug\n##\n## Purpose: Shiny-app to perform differential expression analysis, primarily on proteomics data, to perform\n##          simple data QC, to interactively browse through the results and to download high-quality result\n##          figures.\n##\n## This file defines global parameters, loads all required R-packages and defines the actual functions to perform data filtering,\n## data normalization, the moderated test statistics, and visualization. The code for moderated t-tests,\n## two-component normalization and the reproducibility filter has been written by Mani DR and\n## adopted by me for intergration into a Shiny-Server environment.\n##\n##\n## required packages:\n##\n## cran.pckg <- c('pheatmap', 'RColorBrewer', 'hexbin', 'Hmisc', 'grid', 'scatterplot3d', 'plotly', 'WriteXLS', 'reshape','nlme', 'BlandAltmanLeh', 'mice','mixtools', 'mclust')\n## bioc.pgkg <- c( 'preprocessCore', 'limma')\n##\n## changelog: 20160614 included 'na' to indicate missing values\n##                     outsourced Mani's code to a separate file 'modT.r'\n################################################################################################################\n\nsource('modT.r')\nsource('pheatmap.r')\n\n#################################################################\n## global parameters\n#################################################################\n## version number\nVER=\"0.5.0\"\n## maximal filesize for upload\nMAXSIZEMB <<- 400\n## list of strings indicating missing data\nNASTRINGS <<- c(\"NA\", \"<NA>\", \"#NUM!\", \"#DIV/0!\", \"#NA\", \"#NAME?\", \"na\", \"#VALUE!\")\n## speparator tested in the uploaded file\nSEPARATOR <<- c('\\t', ',', ';')\n## Colors used throughout the app to color the defined groups\nGRPCOLORS <<- c(RColorBrewer::brewer.pal(9, \"Set1\"), RColorBrewer::brewer.pal(8, \"Dark2\"), RColorBrewer::brewer.pal(8, \"Set2\"))\n## number of characters to display in plots/tables for column names\nSTRLENGTH <<- 20\n## operating system\nOS <<- Sys.info()['sysname']\n## temp directory to write the Excel file\nTMPDIR <<- ifelse(OS=='Windows', \"./\", \"/tmp/\")\n## app name\nAPPNAME <<- sub('.*/','',getwd())\n## directory to store data files\nDATADIR <<- ifelse(OS=='Windows', \"./\", \"/local/shiny-data/\")\n\n#################################################################\n## load required packages\n#################################################################\nlibrary(shiny)\n## heatmap\n##library(pheatmap)\nlibrary(scales)\nlibrary(gtable)\n## moderated t-test\nlibrary(limma)\n## colors\nlibrary (RColorBrewer)\n## multiscatter\nlibrary(hexbin)\nlibrary(Hmisc)\nlibrary(grid)\n## pca\nlibrary(scatterplot3d)\nlibrary(plotly)\n## export\nlibrary(WriteXLS)\n## reproducibility filter\nlibrary(reshape)\nlibrary(nlme)\nlibrary(BlandAltmanLeh)\n## normalization Quantile\nlibrary(preprocessCore)\n## normalization 2-component\nlibrary (mice)\nlibrary (mixtools)\nlibrary (mclust)\n\n\n#################################################################################\n##     Heatmap of expression values combining all of the results from all tests\n##\n##\n##\n#################################################################################\nplotHM <- function(res,\n                   grp,\n                   grp.col,\n                   grp.col.legend,\n                   hm.clust,\n                   hm.title,\n                   hm.scale,\n                   style,\n                   filename=NA, cellwidth=NA, cellheight=NA, max.val=NA, fontsize_col, fontsize_row, ...){\n\n    ## convert to data matrix\n    res <- data.matrix(res)\n\n    #########################################\n    ## different 'styles' for different tests\n    ## - reorder columns\n    ## - gaps between experiments\n    if(style == 'One-sample mod T'){\n        res <- res[, names(grp[order(grp)])]\n        gaps_col=cumsum(table(grp[order(grp)]))\n        gapsize_col=20\n    }\n    if(style == 'Two-sample mod T'){\n        res <- res[, names(grp[order(grp)])]\n        gaps_col=NULL\n        gapsize_col=0\n    }\n    if(style == 'mod F' | style == 'none'){\n        res <- res[, names(grp[order(grp)])]\n        gaps_col=NULL\n        gapsize_col=0\n    }\n    #########################################\n    ## scaling\n    if(hm.scale == 'row')\n        res <- t(apply(res, 1, function(x)(x-mean(x, na.rm=T))/sd(x, na.rm=T)))\n    if(hm.scale == 'column')\n        res <- apply(res, 2, function(x)(x-mean(x, na.rm=T))/sd(x, na.rm=T))\n\n    ##########################################\n    ##          cluster\n    ## 20160309 NA handling\n    ##\n    ##########################################\n    na.idx.row <- na.idx.col <- NULL\n\n    ## column clustering\n    if(hm.clust == 'column'){\n        Rowv=FALSE\n        colv.dist = dist(t(res), method='euclidean', diag=T, upper=T)\n        na.idx.col <- which(apply(as.matrix(colv.dist), 1, function(x) sum(is.na(x))) > 0)\n        if(length(na.idx.col)> 0){\n            colv.dist <- colv.dist[-na.idx.col, ]\n            colv.dist <- colv.dist[, -na.idx.col]\n        }\n        Colv=hclust(as.dist(colv.dist), method='complete')\n    ## row clustering\n    } else if( hm.clust == 'row'){\n        rowv.dist <- as.matrix(dist(res, method='euclidean', diag=T, upper=T))\n        na.idx.row <- which(apply(as.matrix(rowv.dist), 1, function(x) sum(is.na(x))) > 0)\n        if(length(na.idx.row)> 0){\n            rowv.dist <- rowv.dist[-na.idx.row, ]\n            rowv.dist <- rowv.dist[, -na.idx.row]\n        }\n        Rowv=hclust(as.dist(rowv.dist), method='complete')\n        Colv=FALSE\n\n    ## row and column clustering\n    } else if(hm.clust == 'both'){\n\n        ## row clustering\n        rowv.dist <- as.matrix(dist(res, method='euclidean', diag=T, upper=T))\n        na.idx.row <- which(apply(as.matrix(rowv.dist), 1, function(x) sum(is.na(x))) > 0)\n        if(length(na.idx.row)> 0){\n            rowv.dist <- rowv.dist[-na.idx.row, ]\n            rowv.dist <- rowv.dist[, -na.idx.row]\n        }\n        Rowv=hclust(as.dist(rowv.dist), method='complete')\n\n        ## column clustering\n        colv.dist = dist(t(res), method='euclidean', diag=T, upper=T)\n        na.idx.col <- which(apply(as.matrix(colv.dist), 1, function(x) sum(is.na(x))) > 0)\n        if(length(na.idx.col)> 0){\n            colv.dist <- colv.dist[-na.idx.col, ]\n            colv.dist <- colv.dist[, -na.idx.col]\n        }\n        Colv=hclust(as.dist(colv.dist), method='complete')\n    } else {\n        Rowv=Colv=FALSE\n    }\n\n    #########################################\n    ## capping\n    if(!is.na(max.val)){\n        res[ res < -max.val ] <- -max.val\n        res[ res > max.val ] <- max.val\n    }\n    #########################################\n    ## min/max value\n    max.val = ceiling( max( abs(res), na.rm=T) )\n    min.val = -max.val\n\n    ##########################################\n    ## colors\n    color.breaks = seq( min.val, max.val, length.out=12 )\n    color.hm = rev(brewer.pal (length(color.breaks)-1, \"RdBu\"))\n    ##color.hm = rev(brewer.pal (length(color.breaks)-1, \"Spectral\"))\n\n    ##############################################\n    ## annotation of columns\n    anno.col=data.frame(Group=grp)\n    anno.col.color=list(Group=grp.col.legend)\n\n    ##############################################\n    ## heatmap title\n    ##hm.title = paste(hm.title, '\\nsig / total: ', nrow(res), ' / ', ,sep='')\n    if(!is.null(na.idx.row) | !is.null(na.idx.col))\n        hm.title = paste(hm.title, '\\nremoved rows / columns: ', length(na.idx.row), ' / ' , length(na.idx.col), sep='')\n\n    ############################################\n    ## plot the heatmap\n    pheatmap(res, fontsize_row=fontsize_row, fontsize_col=fontsize_col,\n             cluster_rows=Rowv, cluster_cols=Colv, border_col=NA, col=color.hm, filename=filename, main=hm.title, annotation_col=anno.col, annotation_colors=anno.col.color, labels_col=chopString(colnames(res), STRLENGTH), breaks=color.breaks, scale='none', cellwidth=cellwidth, cellheight=cellheight, gaps_col=gaps_col, gapsize_col=gapsize_col, labels_row=chopString(rownames(res), STRLENGTH), na_col='black')\n}\n\n\n\n#################################################################################################\n##                     multiscatterplot using hexagonal binning\n## - mat    numerical matrix of expression values, rows are features, columns are samples\n##\n## changelog: 2015116 implementation\n#################################################################################################\nmy.multiscatter <- function(mat, hexbin=30, hexcut=5, cor=c('pearson', 'spearman', 'kendall'), repro.filt=NULL, grp, grp.col.legend, define.max=F, max.val=3, min.val=-3){\n\n    ## cor method\n    corm = match.arg(cor)\n    ## correlation\n    cm = cor(mat, use='pairwise.complete', method=corm)\n\n    ## number of samples to compare\n    N = ncol(mat)\n\n    ## define limits\n    if(define.max){\n        lim=c(min.val, max.val)\n\n    } else{\n        lim=max( abs( mat ), na.rm=T )\n        lim=c(-lim, lim)\n    }\n\n    ###########################################################################\n    ## help function to set up the viewports\n    ## original code from:  http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/\n    multiplot <- function(plots, cols=1) {\n        ## Make a list from the ... arguments and plotlist\n        ##plots <- c(list(...))\n        ## number of plots\n        numPlots = length(plots)\n        ## layout matrix\n        layout <- matrix(seq(1, cols * ceiling(numPlots/cols)), ncol = cols, nrow = ceiling(numPlots/cols))\n        ## Set up the page\n        grid.newpage()\n        ## grid layout\n        la <-  grid.layout(nrow(layout), ncol(layout))\n        pushViewport(viewport(layout = la))\n        ## Make each plot, in the correct location\n        for (i in numPlots:1) {\n            ## Get the i,j matrix positions of the regions that contain this subplot\n            matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))\n            vp = viewport(layout.pos.row = matchidx$row, layout.pos.col = matchidx$col)\n\n            ## textplot: correlation coefficient\n            if(matchidx$row < matchidx$col){\n                numb = plots[[i]]\n                col='black'\n                size = min(max(abs(90*as.numeric(numb)), 25), 50)\n                grid.rect(width=unit(.85, 'npc'), height=unit(.85, 'npc'), vp=vp, gp=gpar(fill='grey95', col='transparent'))\n                grid.text(numb, vp=vp, gp=gpar(fontsize=size, col=col))\n            } else {\n                print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,\n                                                layout.pos.col = matchidx$col))\n            }\n        }\n    } ## end function 'multiplot'\n    #########################################################################\n    ##\n    ##                     do the actual plotting\n    ##\n    #########################################################################\n\n    ## list to store the plots\n    plotList=vector('list', N*N)\n    count=1\n    for(i in 1:N)\n        for(j in 1:N){\n\n            ## extract pairwise data\n            dat <- data.frame(x=mat[,i], y=mat[,j])\n            rownames(dat) <- rownames(mat)\n\n            ## filter according to xlim/ylim\n            dat$x[ which(dat$x < lim[1] | dat$x > lim[2]) ] <- NA\n            dat$y[ which(dat$y < lim[1] | dat$y > lim[2]) ] <- NA\n\n            ## extract groups\n            current.group <- unique(grp[names(grp)[c(i,j)]])\n\n            ##cat(current.group, '\\n')\n            ##str(add.points)\n\n            ###########################\n            ## lower triangle\n            if(i < j){\n\n                ## hexbin\n                ##hex <- hexbin(dat$x, dat$y, hexbin, xbnds=range(dat$x, na.rm=T), ybnds=range(dat$y, na.rm=T) )\n                hex <- hexbin(dat$x, dat$y, hexbin, xbnds=lim, ybnds=lim )\n                gghex <- data.frame(hcell2xy(hex), c = cut2(hex@count, g = hexcut))\n                p <- ggplot(gghex) + geom_hex(aes(x = x, y = y, fill = c) ,stat = \"identity\") + guides(fill=FALSE) + theme( plot.margin=unit(rep(0, 4), 'cm')) + xlab('') + ylab('') + xlim(lim[1], lim[2]) + ylim(lim[1], lim[2])\n\n                ##if(length(current.group) == 1)\n                ##    p <- p + scale_fill_manual( values=paste(rep( grp.col.legend[current.group], hexcut) ))\n                ##else\n\n                p <- p + scale_fill_manual( values=paste('grey', ceiling(seq(70, 20, length.out=hexcut)), sep=''))\n\n                ## add filtered values\n                if(!is.null(repro.filt) & length(current.group) == 1){\n                    not.valid.idx <- repro.filt[[current.group]]\n                    dat.repro <- dat[not.valid.idx, ]\n                    ##cat(not.valid.idx)\n                    ##cat(dim(dat.repro))\n                    p = p + geom_point( aes(x=x, y=y ), data=dat.repro, colour=my.col2rgb('red', 50), size=1)\n                }\n            }\n            ###########################\n            ## diagonal\n            if(i == j){\n                p = ggplot(dat, aes(x=x)) + geom_histogram(fill=grp.col.legend[current.group], colour=grp.col.legend[current.group], binwidth=sum(abs(range(dat$x, na.rm=T)))/50) + ggtitle(colnames(mat)[i]) + theme(plot.title=element_text(size=9)) + theme( panel.background = element_blank(), plot.margin=unit(rep(0, 4), 'cm')) + xlab(paste('N',sum(!is.na(dat$x)), sep='=')) + ylab('') + xlim(lim[1], lim[2]) ##+ annotate('text', label=sum(!is.na(dat$x)), x=unit(0, 'npc'), y=unit(0, 'npc'))\n\n\n            }\n            ###########################\n            ## upper triangle\n            if(i > j){\n                cortmp = cm[i,j]\n\n                p=paste(round(cortmp,2))\n\n            }\n\n            plotList[[count]] <- p\n            count=count+1\n        }\n\n    multiplot( plotList, cols=N)\n}\n\n\n##########################################################################################################\n##                     translate a color name into rgb space\n##\n## changelog:  20100929 implementation\n##########################################################################################################\nmy.col2rgb <- function(color, alpha=80, maxColorValue=255){\n\n    out <- vector( \"character\", length(color) )\n\n    for(col in 1:length(color)){\n\n        col.rgb <- col2rgb(color[col])\n\n        out[col] <- rgb(col.rgb[1], col.rgb[2], col.rgb[3], alpha=alpha, maxColorValue=maxColorValue)\n\n    }\n    return(out)\n}\n\n\n#############################################################################################\n##\n##              different normalization methods for expression data\n##\n## 20160235\n#############################################################################################\nnormalize.data <- function(data, id.col, method=c('Median', 'Quantile', 'Median-MAD', '2-component')){\n    cat('\\n\\n-- normalize data --\\n\\n')\n\n    method = match.arg(method)\n\n    ids = data[, id.col]\n    data = data[ , -grep(paste('^', id.col, '$', sep=''), colnames(data))]\n\n    data <- data.matrix(data)\n\n    ## quantile\n    if(method == 'Quantile'){\n        require(\"preprocessCore\")\n        data.norm <- normalize.quantiles(data)\n        rownames(data.norm) <- rownames(data)\n        colnames(data.norm) <- paste( colnames(data))\n\n\n        ## shift median to zero\n        data.norm <- apply(data.norm, 2, function(x) x - median(x, na.rm=T))\n    }\n    ## median only\n    if(method == 'Median'){\n        data.norm <- apply(data, 2, function(x) x - median(x, na.rm=T))\n        ##rownames(data.norm) <- rownames(data)\n        colnames(data.norm) <- paste( colnames(data), sep='.')\n    }\n    ## median & MAD\n    if(method == 'Median-MAD'){\n        data.norm <- apply(data, 2, function(x) (x - median(x, na.rm=T))/mad(x, na.rm=T) )\n        ##rownames(data.norm) <- rownames(data)\n        colnames(data.norm) <- paste( colnames(data), sep='.')\n    }\n    ## 2-component normalization\n    if(method == '2-component'){\n        data.norm.list = apply(data, 2, two.comp.normalize, type=\"unimodal\")\n        ##cat('\\n\\n here 1\\n\\nlength list:', length(data.norm.list), '\\n')\n        ##save(data.norm.list, file='test.RData')\n        ## check if successful\n        for(i in 1:length(data.norm.list)){\n            ##cat('\\ni=', i, '\\n')\n            if(length(data.norm.list[[i]]) == 1){\n                if(data.norm.list[[i]] == 'No_success'){\n                    ##cat('\\n\\nno success\\n\\n')\n                    return(paste( colnames(data)[i] ))\n                }\n            }\n            ##cat('\\n length:', length(data.norm.list[[i]]), '\\n')\n        }\n        ##cat('\\n\\n here \\n\\n')\n        data.norm = matrix( unlist(lapply(data.norm.list, function(x)x$norm.sample)), ncol=length(data.norm.list), dimnames=list(rownames(data), names(data.norm.list)) )\n    }\n    ## add id column\n    data.norm <- data.frame(ids, data.norm)\n    colnames(data.norm)[1] <- id.col\n    return(data.norm)\n}\n\n\n##############################################################################\n##\n##  - perform principle component analysis\n##  - calculate variances explained by components\n##  - plot the results\n##\n## changelog: 20131001 implementation\n##            20131007 3D plot now plot pc1 vs. pc3 vs. pc2\n##                     instead of pc1 vs. pc2 vs. pc3\n##            20151208 legend\n##            20161103 check number of rows (N), 2D plot only\n##############################################################################\nmy.prcomp <- function(x, col=NULL, cor=T, plot=T, rgl=F, scale=T, pch=20, cex.points=3, rgl.point.size=30, main=\"PCA\", leg.vec=NULL, leg.col=NULL, ...){\n\n    cex.font = 1.8\n\n    ##View(x)\n\n    ## number of data columns, N=2 -> 2D plot only\n    N <- nrow(x)\n\n    ## color\n    if( is.null(col) ) col=\"black\"\n\n    ## perform pca\n    pca <- prcomp(x, scale=scale)\n\n    ##View(pca$x)\n\n    ## calculate variance\n    comp.var <- eigen(cov(pca$x))$values\n\n    ## extract the principle components\n    pc1=pca$x[,1]\n    pc2=pca$x[,2]\n    if(N>2)\n        pc3=pca$x[,3]\n\n    ##############\n    # rgl plot\n    ##############\n    if(rgl & N > 2){\n        require(rgl)\n        plot3d(pc1, pc2, pc3, xlab=paste(\"PC 1 (\", round(100*comp.var[1]/sum(comp.var),1),\"%)\", sep=\"\"), ylab=paste(\"PC 2 (\",round(100*comp.var[2]/sum(comp.var),1),\"%)\", sep=\"\"), zlab=paste(\"PC 3 (\", round(100*comp.var[3]/sum(comp.var),1),\"%)\", sep=\"\"), type=\"s\", col=col, expand=1.2, size=rgl.point.size)\n    }\n\n    ########################################\n    # scatterplot 2D/3D\n    ########################################\n    if( plot){\n\n         require(scatterplot3d)\n\n        if(N > 2)\n            par(mfrow=c(1,3), mar=c(7,7,3,1))\n        if(N <= 2)\n            par(mfrow=c(1,2), mar=c(7,7,3,1))\n\n         ## PC 1-2\n         plot(pc1, pc2, xlab=paste(\"PC 1 (\", round(100*comp.var[1]/sum(comp.var),1),\"%)\", sep=\"\"), ylab=paste(\"PC 2 (\",round(100*comp.var[2]/sum(comp.var),1),\"%)\", sep=\"\"), pch=pch, main=main, col=col, sub=paste(\"Cumulative variance = \", round(100*sum(comp.var[1:2]/sum(comp.var)),1),\"%\", sep=\"\"), cex=cex.points, ylim=c( min(pc2),  max(pc2)+.15*max(pc2)), cex.axis=cex.font, cex.lab=cex.font, cex.sub=cex.font )\n\n\n        if(N > 2) {\n            ## PC 1-3\n            scatterplot3d( pca$x[,1], pca$x[,3], pca$x[,2], xlab=paste(\"PC 1 (\", round(100*comp.var[1]/sum(comp.var),1),\"%)\", sep=\"\"), zlab=paste(\"PC 2 (\",round(100*comp.var[2]/sum(comp.var),1),\"%)\", sep=\"\"), ylab=paste(\"PC 3 (\", round(100*comp.var[3]/sum(comp.var),1),\"%)\", sep=\"\"), color=col,  cex.symbols=cex.points, pch=pch, main=main, sub=paste(\"Cumulative variance = \", round(100*sum(comp.var[1:3]/sum(comp.var)),1),\"%\", sep=\"\"), type=\"h\" )\n\n        }\n        ## legend\n         plot.new()\n         plot.window(xlim=c(0,1), ylim=c(0, 1))\n         if(!is.null(leg.vec) & !is.null(leg.col))\n             legend('topleft', legend=leg.vec, col=leg.col, pch=pch, pt.cex=max(1, cex.points-1.5), ncol=ifelse( length(leg.vec)> 10, 2, 1), bty='n', cex=2 )\n       par(mfrow=c(1,1))\n    }\n\n    return(pca)\n}\n\n#####################################################\n## color ramp\n##\n## ToDo: opacity!\n####################################################\nmyColorRamp <- function(colors, values, range=NULL) {\n\n    if(is.null(range))\n        v <- (values - min(values))/diff(range(values))\n    else\n        v <- (values - min(values, na.rm=T))/diff( range )\n\n    x <- colorRamp(colors)(v)\n    rgb(x[,1], x[,2], x[,3], maxColorValue = 255)\n}\n\n#################################################\n##   Given a string and a number of characters\n##   the function chops the string to the\n##   specified number of characters and adds\n##   '...' to the end.\n## parameter\n##   string     - character\n##   nChar      - numeric\n## value\n##   string of 'nChar' characters followed\n##     by '...'\n##################################################\nchopString <- function(string, nChar=10, add.dots=T)\n{\n\n    string.trim <- strtrim(string, nChar)\n\n    if(add.dots)\n        string.trim[ which(nchar(string) > nChar) ] <-  paste(string.trim[which(nchar(string) > nChar) ], '...')\n    if(!add.dots)\n        string.trim[ which(nchar(string) > nChar) ] <-  paste(string.trim[which(nchar(string) > nChar) ])\n\n    return(string.trim)\n\n}\n\n\n########################################################################\n## 20160224\n##                   reproducibility filter\n##\n## n=2: Bland-Altman\n## n>2: lmm-model written by Mani DR\n##\n## - replaces not reprodicibly measuered values in 'tab' with 'NA'\n##\n########################################################################\nmy.reproducibility.filter <- function(tab, grp.vec, id.col='id', alpha=0.05){\n\n    ## extract groups\n    groups = unique(grp.vec)\n\n    ## list to store index of filtered values per group\n    values.filt <- vector('list', length(groups))\n    names(values.filt) <- groups\n\n    ## add rownames to tab\n    ##rownames(tab) <- tab[, id.col]\n\n    tab.repro.filter <- tab\n   ## View(tab.repro.filter)\n\n    ############################################\n    ## loop over replicate groups\n    for(gg in groups){\n\n        gg.idx = names(grp.vec)[ which(grp.vec == gg) ]\n\n        ########################################\n        ## if there are more than 2 replicates\n        ## use the Mani's lmm model\n        if( length(gg.idx) > 2 ){\n            repro.idx <- reproducibility.filter( tab[, c(id.col, gg.idx)], id.col=id.col, alpha=alpha)\n\n            if(length(repro.idx) != nrow(tab)) stop('Reproducibility vector not of same length as matrix!\\n')\n\n            not.repro.idx <- which(!repro.idx)\n\n            if(length(not.repro.idx) > 0)\n                tab[not.repro.idx, gg.idx] <- NA\n\n            values.filt[[gg]] <- not.repro.idx\n        }\n        ########################################\n        ## if there are two replicates use\n        ## Blandt-Altmann filter\n        ## R-package 'BlandAltmanLeh'\n        if( length(gg.idx) == 2 ){\n\n            ## Bland-Altman\n            ba <-  bland.altman.stats(as.numeric( as.character( tab[, gg.idx[1] ]) ), as.numeric( as.character( tab[,  gg.idx[2] ] )), two=3.290527 )\n            ## calculate diffs on my own..\n            my.diffs <- tab[, gg.idx[1]] - tab[, gg.idx[2]]\n            ## index of outliers\n            ##not.repro.idx <- which( ba$diffs < ba$lower.limit | ba$diffs > ba$upper.limit)\n            not.repro.idx <- which( my.diffs < ba$lower.limit | my.diffs > ba$upper.limit)\n\n            ## set values of outliers to NA\n            if(length(not.repro.idx) > 0)\n                tab[not.repro.idx, gg.idx] <- NA\n\n            ## store the results\n            values.filt[[gg]] <- rownames(tab)[ not.repro.idx ]\n            rm(not.repro.idx)\n        }\n\n    }\n    return(list(table=tab, values.filtered=values.filt))\n}\n\n\n##################################################################\n## function to dynamically determine the height (in px) of the heatmap\n## depending on the number of genes\ndynamicHeightHM <- function(n){\n    if( n < 50)\n        height=500\n    if( n >= 50 & n <= 100)\n        height=800\n    if(n >=100)\n        height=800+n\n    return(height)\n}\n\n###################################################################\n##\n##       generate the boxplots under the 'QC' tab\n##\n###################################################################\nmakeBoxplot <- function(tab, id.col, grp, grp.col, grp.col.leg, legend=T, cex.lab=1.5, mar=c(4,15,2,6)){\n\n\t cat('\\n-- makeBoxplot --\\n')\n\n    ## table\n    tab <- tab[, setdiff(colnames(tab), id.col)]\n\n\t##\tcat(id.col)\n\n    ##########################################\n    ## order after groups\n    ord.idx <- order(grp)\n    grp <- grp[ord.idx]\n    tab <- tab[, ord.idx]\n    grp.col <- grp.col[ ord.idx]\n\n\n    at.vec=1:ncol(tab)\n    ##########################################\n    ## plot\n    par(mar=mar)\n    boxplot(tab, pch=20, col='white', outline=T, horizontal=T, las=2, xlab=expression(log[2](ratio)), border=grp.col, at=at.vec, axes=F, main='', cex=2, xlim=c(0, ifelse(legend, ncol(tab)+2, ncol(tab)) ))\n    ##legend('top', legend=names(grp.col.leg), ncol=2, bty='n', border = names(grp.col.leg), fill='white', cex=1.5)\n    if(legend)\n        legend('top', legend=names(grp.col.leg), ncol=length(grp.col.leg), bty='n', border = grp.col.leg, fill=grp.col.leg, cex=cex.lab)\n    ##legend('top', legend=c(input$label.g1, input$label.g2), ncol=2, bty='n', border = c('grey10', 'darkblue'), fill='white', cex=1.5, lwd=3)\n    mtext( paste('N=',unlist(apply(tab,2, function(x)sum(!is.na(x)))), sep=''), at=at.vec, side=4, las=2, adj=0, cex.lab=cex.lab)\n    axis(1)\n    axis(2, at=at.vec, labels=chopString(colnames(tab), STRLENGTH), las=2, cex=cex.lab)\n\n}\n\n###################################################################\n##\n##       generate the profile plots under the 'QC' tab\n##\n###################################################################\nmakeProfileplot <- function(tab, id.col, grp, grp.col, grp.col.leg, legend=T, cex.lab=1.5, mar=c(5,5,3,1), ... ){\n\n    cat('\\n-- makeProfileplot --\\n')\n\n    ## table\n    tab <- tab[, setdiff(colnames(tab), id.col)]\n\n    xlim=max(abs(tab), na.rm=T)\n\n    ## caclulate densities\n    dens <- apply(tab, 2, density, na.rm=T)\n\n    ## ylim\n    ylim <- max(unlist(lapply(dens, function(x) max(x$y))))\n\n    ##########################################\n    ## plot\n    par(mar=mar)\n    for(i in 1:ncol(tab)){\n        if(i == 1)\n            plot(dens[[i]], xlab='expression', xlim=c(-xlim, xlim), ylim=c(0, ylim), col=my.col2rgb(grp.col[i], alpha=100), lwd=3, cex.axis=2, cex.lab=2, cex.main=1.5, ...)\n        else\n            lines(dens[[i]], col=my.col2rgb(grp.col[i], alpha=100), lwd=3)\n\n        ## divide legend if there are too many experiments\n        N.exp <- length(names(grp.col.leg))\n        if( N.exp > 15){\n            legend('topright', legend=names(grp.col.leg)[1:floor(N.exp/2)], col=grp.col.leg[1:floor(N.exp/2)], lty='solid', bty='n', cex=1.5, lwd=3)\n            legend('topleft', legend=names(grp.col.leg)[ceiling(N.exp/2):N.exp], col=grp.col.leg[ceiling(N.exp/2):N.exp], lty='solid', bty='n', cex=1.5, lwd=3)\n\n        } else\n            legend('topright', legend=names(grp.col.leg), col=grp.col.leg, lty='solid', bty='n', cex=1.5, lwd=3)\n    }\n\n    cat('\\n-- makeProfileplot exit --\\n')\n}\n",
    "created" : 1477430857940.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3920842296",
    "id" : "14B13BE3",
    "lastKnownWriteTime" : 1478122692,
    "last_content_update" : 1478122692,
    "path" : "C:/DATA/ShinyApps/modT/global.r",
    "project_path" : "global.r",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}